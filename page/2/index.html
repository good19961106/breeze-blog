<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://good19961106.github.io/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/breeze-blog/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/breeze-blog/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/breeze-blog/css/style.css">

  
    
<link rel="stylesheet" href="/breeze-blog/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/breeze-blog/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/breeze-blog/">Home</a>
        
          <a class="main-nav-link" href="/breeze-blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/breeze-blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://good19961106.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-rabbitmq/rabbitmq-how-to-use-delay-queue" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/breeze-blog/2020/05/04/rabbitmq/rabbitmq-how-to-use-delay-queue/" class="article-date">
  <time class="dt-published" datetime="2020-05-03T16:00:50.000Z" itemprop="datePublished">2020-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/breeze-blog/categories/%E7%BC%96%E7%A8%8B/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/breeze-blog/2020/05/04/rabbitmq/rabbitmq-how-to-use-delay-queue/">【RabbitMQ】一文带你搞定RabbitMQ延迟队列</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文口味：鱼香肉丝   预计阅读：10分钟</p>
<h2 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h2><p>在上一篇中，介绍了RabbitMQ中的死信队列是什么，何时使用以及如何使用RabbitMQ的死信队列。相信通过上一篇的学习，对于死信队列已经有了更多的了解，这一篇的内容也跟死信队列息息相关，如果你还不了解死信队列，那么建议你先进行上一篇文章的阅读。</p>
<p>这一篇里，我们将继续介绍RabbitMQ的高级特性，通过本篇的学习，你将收获：</p>
<ol>
<li>什么是延时队列</li>
<li>延时队列使用场景</li>
<li>RabbitMQ中的TTL</li>
<li>如何利用RabbitMQ来实现延时队列</li>
</ol>
<h2 id="二、本文大纲"><a href="#二、本文大纲" class="headerlink" title="二、本文大纲"></a>二、本文大纲</h2><p>以下是本文大纲：</p>
<p><img src="https://i.loli.net/2019/07/28/5d3d74d99699d43032.png" alt="1.png"></p>
<p>本文阅读前，需要对RabbitMQ以及死信队列有一个简单的了解。</p>
<h2 id="三、什么是延时队列"><a href="#三、什么是延时队列" class="headerlink" title="三、什么是延时队列"></a>三、什么是延时队列</h2><p><code>延时队列</code>，首先，它是一种队列，队列意味着内部的元素是<code>有序</code>的，元素出队和入队是有方向性的，元素从一端进入，从另一端取出。</p>
<p>其次，<code>延时队列</code>，最重要的特性就体现在它的<code>延时</code>属性上，跟普通的队列不一样的是，<code>普通队列中的元素总是等着希望被早点取出处理，而延时队列中的元素则是希望被在指定时间得到取出和处理</code>，所以延时队列中的元素是都是带时间属性的，通常来说是需要被处理的消息或者任务。</p>
<p>简单来说，延时队列就是用来存放需要在指定时间被处理的元素的队列。</p>
<h2 id="四、延时队列使用场景"><a href="#四、延时队列使用场景" class="headerlink" title="四、延时队列使用场景"></a>四、延时队列使用场景</h2><p>那么什么时候需要用延时队列呢？考虑一下以下场景：</p>
<ol>
<li>订单在十分钟之内未支付则自动取消。</li>
<li>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。</li>
<li>账单在一周内未支付，则自动结算。</li>
<li>用户注册成功后，如果三天内没有登陆则进行短信提醒。</li>
<li>用户发起退款，如果三天内没有得到处理则通知相关运营人员。</li>
<li>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议。</li>
</ol>
<p>这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如：发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；发生店铺创建事件，十天后检查该店铺上新商品数，然后通知上新数为0的商户；发生账单生成事件，检查账单支付状态，然后自动结算未支付的账单；发生新用户注册事件，三天后检查新注册用户的活动数据，然后通知没有任何活动记录的用户；发生退款事件，在三天之后检查该订单是否已被处理，如仍未被处理，则发送消息给相关运营人员；发生预定会议事件，判断离会议开始是否只有十分钟了，如果是，则通知各个与会人员。</p>
<p>看起来似乎使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？如果数据量比较少，确实可以这样做，比如：对于“如果账单一周内未支付则进行自动结算”这样的需求，如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：“订单十分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。</p>
<p>更重要的一点是，不！优！雅！</p>
<p>没错，作为一名有追求的程序员，始终应该追求更优雅的架构和更优雅的代码风格，写代码要像写诗一样优美。【滑稽】</p>
<p>这时候，延时队列就可以闪亮登场了，以上场景，正是延时队列的用武之地。</p>
<p>既然<code>延时队列</code>可以解决很多特定场景下，带时间属性的任务需求，那么如何构造一个延时队列呢？接下来，本文将介绍如何用RabbitMQ来实现延时队列。</p>
<h2 id="五、RabbitMQ中的TTL"><a href="#五、RabbitMQ中的TTL" class="headerlink" title="五、RabbitMQ中的TTL"></a>五、RabbitMQ中的TTL</h2><p>在介绍延时队列之前，还需要先介绍一下RabbitMQ中的一个高级特性——<code>TTL（Time To Live）</code>。</p>
<p><code>TTL</code>是什么呢？<code>TTL</code>是RabbitMQ中一个消息或者队列的属性，表明<code>一条消息或者该队列中的所有消息的最大存活时间</code>，单位是毫秒。换句话说，如果一条消息设置了TTL属性或者进入了设置TTL属性的队列，那么这条消息如果在TTL设置的时间内没有被消费，则会成为“死信”（至于什么是死信，请翻看上一篇）。如果同时配置了队列的TTL和消息的TTL，那么较小的那个值将会被使用。</p>
<p>那么，如何设置这个TTL值呢？有两种方式，第一种是在创建队列的时候设置队列的“x-message-ttl”属性，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">6000</span>);</span><br><span class="line">channel.queueDeclare(queueName, durable, exclusive, autoDelete, args);</span><br></pre></td></tr></table></figure>
<p>这样所有被投递到该队列的消息都最多不会存活超过6s。</p>
<p>另一种方式便是针对每条消息设置TTL，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties.Builder builder = <span class="keyword">new</span> AMQP.BasicProperties.Builder();</span><br><span class="line">builder.expiration(<span class="string">&quot;6000&quot;</span>);</span><br><span class="line">AMQP.BasicProperties properties = builder.build();</span><br><span class="line">channel.basicPublish(exchangeName, routingKey, mandatory, properties, <span class="string">&quot;msg body&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure>
<p>这样这条消息的过期时间也被设置成了6s。</p>
<p>但这两种方式是有区别的，<strong>如果设置了队列的TTL属性，那么一旦消息过期，就会被队列丢弃，而第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间。</strong></p>
<p>另外，还需要注意的一点是，如果不设置TTL，表示消息永远不会过期，如果将TTL设置为0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。</p>
<h2 id="六、如何利用RabbitMQ实现延时队列"><a href="#六、如何利用RabbitMQ实现延时队列" class="headerlink" title="六、如何利用RabbitMQ实现延时队列"></a>六、如何利用RabbitMQ实现延时队列</h2><p>前一篇里介绍了如果设置死信队列，前文中又介绍了TTL，至此，利用RabbitMQ实现延时队列的两大要素已经集齐，接下来只需要将它们进行调和，再加入一点点调味料，延时队列就可以新鲜出炉了。</p>
<p>想想看，<code>延时队列</code>，不就是想要消息延迟多久被处理吗，TTL则刚好能让消息在延迟多久之后成为死信，另一方面，成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就万事大吉了，因为里面的消息都是希望被立即处理的消息。</p>
<p>从下图可以大致看出消息的流向：</p>
<p><img src="https://i.loli.net/2019/07/28/5d3d743143ecc85643.png" alt="23.png"></p>
<p>生产者生产一条延时消息，根据需要延时时间的不同，利用不同的routingkey将消息路由到不同的延时队列，每个队列都设置了不同的TTL属性，并绑定在同一个死信交换机中，消息过期后，根据routingkey的不同，又会被路由到不同的死信队列中，消费者只需要监听对应的死信队列进行处理即可。</p>
<p>下面来看代码：</p>
<p>先声明交换机、队列以及他们的绑定关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAY_EXCHANGE_NAME = <span class="string">&quot;delay.queue.demo.business.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAY_QUEUEA_NAME = <span class="string">&quot;delay.queue.demo.business.queuea&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAY_QUEUEA_ROUTING_KEY = <span class="string">&quot;delay.queue.demo.business.queuea.routingkey&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAY_QUEUEB_ROUTING_KEY = <span class="string">&quot;delay.queue.demo.business.queueb.routingkey&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_LETTER_EXCHANGE = <span class="string">&quot;delay.queue.demo.deadletter.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_LETTER_QUEUEA_ROUTING_KEY = <span class="string">&quot;delay.queue.demo.deadletter.delay_10s.routingkey&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_LETTER_QUEUEB_ROUTING_KEY = <span class="string">&quot;delay.queue.demo.deadletter.delay_60s.routingkey&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_LETTER_QUEUEA_NAME = <span class="string">&quot;delay.queue.demo.deadletter.queuea&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_LETTER_QUEUEB_NAME = <span class="string">&quot;delay.queue.demo.deadletter.queueb&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明延时Exchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;delayExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">delayExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(DELAY_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信Exchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;deadLetterExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">deadLetterExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(DEAD_LETTER_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明延时队列A 延时10s</span></span><br><span class="line">    <span class="comment">// 并绑定到对应的死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;delayQueueA&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">delayQueueA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// x-dead-letter-exchange    这里声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">// x-dead-letter-routing-key  这里声明当前队列的死信路由key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, DEAD_LETTER_QUEUEA_ROUTING_KEY);</span><br><span class="line">        <span class="comment">// x-message-ttl  声明队列的TTL</span></span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">6000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(DEAD_LETTER_QUEUEA_NAME).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明延时队列B 延时 60s</span></span><br><span class="line">    <span class="comment">// 并绑定到对应的死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;delayQueueB&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">delayQueueB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// x-dead-letter-exchange    这里声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">// x-dead-letter-routing-key  这里声明当前队列的死信路由key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, DEAD_LETTER_QUEUEB_ROUTING_KEY);</span><br><span class="line">        <span class="comment">// x-message-ttl  声明队列的TTL</span></span><br><span class="line">        args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">60000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(DEAD_LETTER_QUEUEB_NAME).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列A 用于接收延时10s处理的消息</span></span><br><span class="line">    <span class="meta">@Bean(&quot;deadLetterQueueA&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">deadLetterQueueA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(DEAD_LETTER_QUEUEA_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列B 用于接收延时60s处理的消息</span></span><br><span class="line">    <span class="meta">@Bean(&quot;deadLetterQueueB&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">deadLetterQueueB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(DEAD_LETTER_QUEUEB_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明延时队列A绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">delayBindingA</span><span class="params">(<span class="meta">@Qualifier(&quot;delayQueueA&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="meta">@Qualifier(&quot;delayExchange&quot;)</span> DirectExchange exchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(DELAY_QUEUEA_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明业务队列B绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">delayBindingB</span><span class="params">(<span class="meta">@Qualifier(&quot;delayQueueB&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="meta">@Qualifier(&quot;delayExchange&quot;)</span> DirectExchange exchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(DELAY_QUEUEB_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列A绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">deadLetterBindingA</span><span class="params">(<span class="meta">@Qualifier(&quot;deadLetterQueueA&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="meta">@Qualifier(&quot;deadLetterExchange&quot;)</span> DirectExchange exchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEA_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列B绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">deadLetterBindingB</span><span class="params">(<span class="meta">@Qualifier(&quot;deadLetterQueueB&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="meta">@Qualifier(&quot;deadLetterExchange&quot;)</span> DirectExchange exchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEB_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，创建两个消费者，分别对两个死信队列的消息进行消费：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLetterQueueConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = DEAD_LETTER_QUEUEA_NAME)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveA</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;,死信队列A收到消息：&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date().toString(), msg);</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = DEAD_LETTER_QUEUEB_NAME)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveB</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;,死信队列B收到消息：&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date().toString(), msg);</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是消息的生产者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayMessageSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String msg, DelayTypeEnum type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">            <span class="keyword">case</span> DELAY_10s:</span><br><span class="line">                rabbitTemplate.convertAndSend(DELAY_EXCHANGE_NAME, DELAY_QUEUEA_ROUTING_KEY, msg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DELAY_60s:</span><br><span class="line">                rabbitTemplate.convertAndSend(DELAY_EXCHANGE_NAME, DELAY_QUEUEB_ROUTING_KEY, msg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们暴露一个web接口来生产消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;rabbitmq&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQMsgController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DelayMessageSender sender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;sendmsg&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String msg, Integer delayType)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：&#123;&#125;,收到请求，msg:&#123;&#125;,delayType:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date(), msg, delayType);</span><br><span class="line">        sender.sendMsg(msg, Objects.requireNonNull(DelayTypeEnum.getDelayTypeEnumByValue(delayType)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>准备就绪，启动！</p>
<p>打开rabbitMQ的<a target="_blank" rel="noopener" href="http://localhost:15672/">管理后台</a>，可以看到我们刚才创建的交换机和队列信息：</p>
<p><img src="https://i.loli.net/2019/07/28/5d3d54e15534398514.png" alt="2.png"></p>
<p><img src="https://i.loli.net/2019/07/28/5d3d54e17df8183993.png" alt="4.png"></p>
<p><img src="https://i.loli.net/2019/07/28/5d3d54e16952546955.png" alt="3.png"></p>
<p>接下来，我们来发送几条消息，<a target="_blank" rel="noopener" href="http://localhost:8080/rabbitmq/sendmsg?msg=testMsg1&amp;delayType=1">http://localhost:8080/rabbitmq/sendmsg?msg=testMsg1&amp;delayType=1</a> <a target="_blank" rel="noopener" href="http://localhost:8080/rabbitmq/sendmsg?msg=testMsg2&amp;delayType=2">http://localhost:8080/rabbitmq/sendmsg?msg=testMsg2&amp;delayType=2</a></p>
<p>日志如下：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span><span class="literal">-07</span><span class="literal">-28</span> <span class="number">16</span>:<span class="number">02</span>:<span class="number">19.813</span>  INFO <span class="number">3860</span> --- [<span class="type">nio</span>-<span class="number">8080</span>-<span class="type">exec</span>-<span class="number">9</span>] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul <span class="number">28</span> <span class="number">16</span>:<span class="number">02</span>:<span class="number">19</span> CST <span class="number">2019</span>,收到请求，msg:testMsg1,delayType:<span class="number">1</span></span><br><span class="line"><span class="number">2019</span><span class="literal">-07</span><span class="literal">-28</span> <span class="number">16</span>:<span class="number">02</span>:<span class="number">19.815</span>  INFO <span class="number">3860</span> --- [<span class="type">nio</span>-<span class="number">8080</span>-<span class="type">exec</span>-<span class="number">9</span>] .l.DirectReplyToMessageListenerContainer : SimpleConsumer [<span class="type">queue</span>=<span class="type">amq.rabbitmq.reply</span>-<span class="type">to</span>, <span class="type">consumerTag</span>=<span class="type">amq.ctag</span>-<span class="type">o</span>-<span class="type">qPpkWIkRm73DIrOIVhig</span> <span class="type">identity</span>=<span class="number">766339</span>] started</span><br><span class="line"><span class="number">2019</span><span class="literal">-07</span><span class="literal">-28</span> <span class="number">16</span>:<span class="number">02</span>:<span class="number">25.829</span>  INFO <span class="number">3860</span> --- [<span class="type">ntContainer</span><span class="comment">#1-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 16:02:25 CST 2019,死信队列A收到消息：testMsg1</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">07</span>-<span class="number">28</span> <span class="number">16</span>:<span class="number">02</span>:<span class="number">41.326</span>  <span class="type">INFO</span> <span class="number">3860</span> --- [<span class="type">nio</span>-<span class="number">8080</span>-<span class="type">exec</span>-<span class="number">1</span>] <span class="type">c.m.d.controller.RabbitMQMsgController</span>   : 当前时间：<span class="type">Sun</span> <span class="type">Jul</span> <span class="number">28</span> <span class="number">16</span>:<span class="number">02</span>:<span class="number">41</span> <span class="type">CST</span> <span class="number">2019</span>,收到请求，<span class="type">msg</span>:<span class="type">testMsg2</span>,<span class="type">delayType</span>:<span class="number">2</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">07</span>-<span class="number">28</span> <span class="number">16</span>:<span class="number">03</span>:<span class="number">41.329</span>  <span class="type">INFO</span> <span class="number">3860</span> --- [<span class="type">ntContainer</span><span class="comment">#0-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 16:03:41 CST 2019,死信队列B收到消息：testMsg2</span></span><br></pre></td></tr></table></figure>
<p>第一条消息在6s后变成了死信消息，然后被消费者消费掉，第二条消息在60s之后变成了死信消息，然后被消费掉，这样，一个还算ok的延时队列就打造完成了。</p>
<p>不过，等等，如果这样使用的话，岂不是每增加一个新的时间需求，就要新增一个队列，这里只有6s和60s两个时间选项，如果需要一个小时后处理，那么就需要增加TTL为一个小时的队列，如果是预定会议室然后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？？</p>
<p>嗯，仔细想想，事情并不简单。</p>
<h2 id="七、RabbitMQ延时队列优化"><a href="#七、RabbitMQ延时队列优化" class="headerlink" title="七、RabbitMQ延时队列优化"></a>七、RabbitMQ延时队列优化</h2><p>显然，需要一种更通用的方案才能满足需求，那么就只能将TTL设置在消息属性里了。我们来试一试。</p>
<p>增加一个延时队列，用于接收设置为任意延时时长的消息，增加一个相应的死信队列和routingkey：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAY_EXCHANGE_NAME = <span class="string">&quot;delay.queue.demo.business.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAY_QUEUEC_NAME = <span class="string">&quot;delay.queue.demo.business.queuec&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAY_QUEUEC_ROUTING_KEY = <span class="string">&quot;delay.queue.demo.business.queuec.routingkey&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_LETTER_EXCHANGE = <span class="string">&quot;delay.queue.demo.deadletter.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_LETTER_QUEUEC_ROUTING_KEY = <span class="string">&quot;delay.queue.demo.deadletter.delay_anytime.routingkey&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_LETTER_QUEUEC_NAME = <span class="string">&quot;delay.queue.demo.deadletter.queuec&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明延时Exchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;delayExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">delayExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(DELAY_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信Exchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;deadLetterExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">deadLetterExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(DEAD_LETTER_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明延时队列C 不设置TTL</span></span><br><span class="line">    <span class="comment">// 并绑定到对应的死信交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;delayQueueC&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">delayQueueC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// x-dead-letter-exchange    这里声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">// x-dead-letter-routing-key  这里声明当前队列的死信路由key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, DEAD_LETTER_QUEUEC_ROUTING_KEY);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(DELAY_QUEUEC_NAME).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列C 用于接收延时任意时长处理的消息</span></span><br><span class="line">    <span class="meta">@Bean(&quot;deadLetterQueueC&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">deadLetterQueueC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(DEAD_LETTER_QUEUEC_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明延时列C绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">delayBindingC</span><span class="params">(<span class="meta">@Qualifier(&quot;delayQueueC&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="meta">@Qualifier(&quot;delayExchange&quot;)</span> DirectExchange exchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(DELAY_QUEUEC_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列C绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">deadLetterBindingC</span><span class="params">(<span class="meta">@Qualifier(&quot;deadLetterQueueC&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="meta">@Qualifier(&quot;deadLetterExchange&quot;)</span> DirectExchange exchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEC_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>增加一个死信队列C的消费者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = DEAD_LETTER_QUEUEC_NAME)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveC</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">    log.info(<span class="string">&quot;当前时间：&#123;&#125;,死信队列C收到消息：&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date().toString(), msg);</span><br><span class="line">    channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次启动！然后访问：<a target="_blank" rel="noopener" href="http://localhost:8080/rabbitmq/delayMsg?msg=testMsg1delayTime=5000">http://localhost:8080/rabbitmq/delayMsg?msg=testMsg1delayTime=5000</a> 来生产消息，注意这里的单位是毫秒。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-07-28 16:45:07.033  INFO 31468 --- [nio-8080-exec-4] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul 28 16:45:07 CST 2019,收到请求，msg:testMsg1,delayTime:5000</span><br><span class="line">2019-07-28 16:45:11.694  INFO 31468 --- [nio-8080-exec-5] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul 28 16:45:11 CST 2019,收到请求，msg:testMsg2,delayTime:5000</span><br><span class="line">2019-07-28 16:45:12.048  INFO 31468 --- [ntContainer#1-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 16:45:12 CST 2019,死信队列C收到消息：testMsg1</span><br><span class="line">2019-07-28 16:45:16.709  INFO 31468 --- [ntContainer#1-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 16:45:16 CST 2019,死信队列C收到消息：testMsg2</span><br></pre></td></tr></table></figure>
<p>看起来似乎没什么问题，但不要高兴的太早，在最开始的时候，就介绍过，如果使用在消息属性上设置TTL的方式，消息可能并不会按时“死亡“，因为RabbitMQ只会检查第一个消息是否过期，如果过期则丢到死信队列，索引如果第一个消息的延时时长很长，而第二个消息的延时时长很短，则第二个消息并不会优先得到执行。</p>
<p>实验一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-07-28 16:49:02.957  INFO 31468 --- [nio-8080-exec-8] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul 28 16:49:02 CST 2019,收到请求，msg:longDelayedMsg,delayTime:20000</span><br><span class="line">2019-07-28 16:49:10.671  INFO 31468 --- [nio-8080-exec-9] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul 28 16:49:10 CST 2019,收到请求，msg:shortDelayedMsg,delayTime:2000</span><br><span class="line">2019-07-28 16:49:22.969  INFO 31468 --- [ntContainer#1-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 16:49:22 CST 2019,死信队列C收到消息：longDelayedMsg</span><br><span class="line">2019-07-28 16:49:22.970  INFO 31468 --- [ntContainer#1-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 16:49:22 CST 2019,死信队列C收到消息：shortDelayedMsg</span><br></pre></td></tr></table></figure>
<p>我们先发了一个延时时长为20s的消息，然后发了一个延时时长为2s的消息，结果显示，第二个消息会在等第一个消息成为死信后才会“死亡“。</p>
<h2 id="八、利用RabbitMQ插件实现延迟队列"><a href="#八、利用RabbitMQ插件实现延迟队列" class="headerlink" title="八、利用RabbitMQ插件实现延迟队列"></a>八、利用RabbitMQ插件实现延迟队列</h2><p>上文中提到的问题，确实是一个硬伤，如果不能实现在消息粒度上添加TTL，并使其在设置的TTL时间及时死亡，就无法设计成一个通用的延时队列。</p>
<p>那如何解决这个问题呢？不要慌，安装一个插件即可：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/community-plugins.html">https://www.rabbitmq.com/community-plugins.html</a> ，下载rabbitmq_delayed_message_exchange插件，然后解压放置到RabbitMQ的插件目录。</p>
<p>接下来，进入RabbitMQ的安装目录下的sbin目录，执行下面命令让该插件生效，然后重启RabbitMQ。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure>
<p>然后，我们再声明几个Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedRabbitMQConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_QUEUE_NAME = <span class="string">&quot;delay.queue.demo.delay.queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_EXCHANGE_NAME = <span class="string">&quot;delay.queue.demo.delay.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAYED_ROUTING_KEY = <span class="string">&quot;delay.queue.demo.delay.routingkey&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">immediateQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(DELAYED_QUEUE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CustomExchange <span class="title">customExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        args.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomExchange(DELAYED_EXCHANGE_NAME, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingNotify</span><span class="params">(<span class="meta">@Qualifier(&quot;immediateQueue&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="meta">@Qualifier(&quot;customExchange&quot;)</span> CustomExchange customExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(customExchange).with(DELAYED_ROUTING_KEY).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>controller层再添加一个入口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;delayMsg2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delayMsg2</span><span class="params">(String msg, Integer delayTime)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;当前时间：&#123;&#125;,收到请求，msg:&#123;&#125;,delayTime:&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date(), msg, delayTime);</span><br><span class="line">    sender.sendDelayMsg(msg, delayTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息生产者的代码也需要修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendDelayMsg</span><span class="params">(String msg, Integer delayTime)</span> </span>&#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, msg, a -&gt;&#123;</span><br><span class="line">        a.getMessageProperties().setDelay(delayTime);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，再创建一个消费者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = DELAYED_QUEUE_NAME)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveD</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">    log.info(<span class="string">&quot;当前时间：&#123;&#125;,延时队列收到消息：&#123;&#125;&quot;</span>, <span class="keyword">new</span> Date().toString(), msg);</span><br><span class="line">    channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一切准备就绪，启动！然后分别访问以下链接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;rabbitmq&#x2F;delayMsg2?msg&#x3D;msg1&amp;delayTime&#x3D;20000</span><br><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;rabbitmq&#x2F;delayMsg2?msg&#x3D;msg2&amp;delayTime&#x3D;2000</span><br></pre></td></tr></table></figure>
<p>日志如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">07</span>-<span class="number">28</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">13.729</span>  INFO <span class="number">25804</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">2</span>] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul <span class="number">28</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">13</span> CST <span class="number">2019</span>,收到请求，msg:msg1,delayTime:<span class="number">20000</span></span><br><span class="line"><span class="number">2019</span>-<span class="number">07</span>-<span class="number">28</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">20.607</span>  INFO <span class="number">25804</span> --- [nio-<span class="number">8080</span>-exec-<span class="number">1</span>] c.m.d.controller.RabbitMQMsgController   : 当前时间：Sun Jul <span class="number">28</span> <span class="number">17</span>:<span class="number">28</span>:<span class="number">20</span> CST <span class="number">2019</span>,收到请求，msg:msg2,delayTime:<span class="number">2000</span></span><br><span class="line">2019-07-28 17:28:22.624  INFO 25804 --- [ntContainer#1-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 17:28:22 CST 2019,延时队列收到消息：msg2</span><br><span class="line">2019-07-28 17:28:33.751  INFO 25804 --- [ntContainer#1-1] c.m.d.mq.DeadLetterQueueConsumer         : 当前时间：Sun Jul 28 17:28:33 CST 2019,延时队列收到消息：msg1</span><br></pre></td></tr></table></figure>
<p>第二个消息被先消费掉了，符合预期。至此，RabbitMQ实现延时队列的部分就完结了。</p>
<h2 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h2><p>延时队列在需要延时处理的场景下非常有用，使用RabbitMQ来实现延时队列可以很好的利用RabbitMQ的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过RabbitMQ集群的特性，可以很好的解决单点故障问题，不会因为单个节点挂掉导致延时队列不可用或者消息丢失。</p>
<p>当然，延时队列还有很多其它选择，比如利用Java的DelayQueu，利用Redis的zset，利用Quartz或者利用kafka的时间轮，这些方式各有特点，但就像炉石传说一般，这些知识就好比手里的卡牌，知道的越多，可以用的卡牌也就越多，遇到问题便能游刃有余，所以需要大量的知识储备和经验积累才能打造出更出色的卡牌组合，让自己解决问题的能力得到更好的提升。</p>
<p>但另一方面，随着时间的流逝和阅历的增长，越来越感觉到自己的能力有限，无法独自面对纷繁复杂且多变的业务需求，在很多方面需要其他人的协助才能很好的完成任务。也知道闻道有先后，术业有专攻，不会再狂妄自大，觉得自己能把所有事情都搞定，也将重心慢慢转移到研究如何有效的进行团队合作上来，我相信一个高度协调的团队永远比一个人战斗要更有价值。</p>
<p>花了一个周末的时间完成了这篇文章，文中所有的代码都上传到了<a target="_blank" rel="noopener" href="https://github.com/MFrank2016/delayed-queue-demo">github</a>如有需要可以自行查阅，希望能对你有帮助，如果有错误的地方，欢迎指正，也欢迎关注我的公众号进行留言交流。</p>
<p><img src="https://i.loli.net/2019/07/14/5d2af6692a8f432182.png" alt="TIM图片20190714173105.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://good19961106.github.io/2020/05/04/rabbitmq/rabbitmq-how-to-use-delay-queue/" data-id="ckjjnjnds0041a8wcbb234n3z" data-title="【RabbitMQ】一文带你搞定RabbitMQ延迟队列" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breeze-blog/tags/DelayQueue/" rel="tag">DelayQueue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breeze-blog/tags/RabbitMQ/" rel="tag">RabbitMQ</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-rabbitmq/rabbitmq-how-to-use-dead-letter-queue" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/breeze-blog/2020/05/04/rabbitmq/rabbitmq-how-to-use-dead-letter-queue/" class="article-date">
  <time class="dt-published" datetime="2020-05-03T16:00:40.000Z" itemprop="datePublished">2020-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/breeze-blog/categories/%E7%BC%96%E7%A8%8B/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/breeze-blog/2020/05/04/rabbitmq/rabbitmq-how-to-use-dead-letter-queue/">【RabbitMQ】一文带你搞定RabbitMQ死信队列</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文口味：爆炒鱿鱼   预计阅读：15分钟</p>
<h2 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h2><p>RabbitMQ是流行的开源消息队列系统，使用erlang语言开发，由于其社区活跃度高，维护更新较快，性能稳定，深得很多企业的欢心（当然，也包括我现在所在公司【手动滑稽】）。</p>
<p>为了保证订单业务的消息数据不丢失，需要使用到RabbitMQ的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。但由于对死信队列的概念及配置不熟悉，导致曾一度陷入百度的汪洋大海，无法自拔，很多文章都看起来可行，但是实际上却并不能帮我解决实际问题。最终，在官网文档中找到了我想要的答案，通过官网文档的学习，才发现对于死信队列存在一些误解，导致配置死信队列之路困难重重。</p>
<p>于是本着记录和分享的精神，将死信队列的概念和配置完整的写下来，以便帮助遇到同样问题的朋友。</p>
<h2 id="二、本文大纲"><a href="#二、本文大纲" class="headerlink" title="二、本文大纲"></a>二、本文大纲</h2><p>以下是本文大纲：</p>
<p><img src="https://i.loli.net/2019/07/14/5d2af4176d1d483480.png" alt="AG4T332}_NEUNPUAU(A_)U6.png"></p>
<p>本文阅读前，需要对RabbitMQ有一个简单的了解，偏向实战配置讲解。</p>
<h2 id="三、死信队列是什么"><a href="#三、死信队列是什么" class="headerlink" title="三、死信队列是什么"></a>三、死信队列是什么</h2><p>死信，在官网中对应的单词为“Dead Letter”，可以看出翻译确实非常的简单粗暴。那么死信是个什么东西呢？</p>
<p>“死信”是RabbitMQ中的一种消息机制，当你在消费消息时，如果队列里的消息出现以下情况：</p>
<ol>
<li>消息被否定确认，使用 <code>channel.basicNack</code>  或 <code>channel.basicReject</code> ，并且此时<code>requeue</code> 属性被设置为<code>false</code>。</li>
<li>消息在队列的存活时间超过设置的TTL时间。</li>
<li>消息队列的消息数量已经超过最大队列长度。</li>
</ol>
<p>那么该消息将成为“死信”。</p>
<p>“死信”消息会被RabbitMQ进行特殊处理，如果配置了死信队列信息，那么该消息将会被丢进死信队列中，如果没有配置，则该消息将会被丢弃。</p>
<h2 id="四、如何配置死信队列"><a href="#四、如何配置死信队列" class="headerlink" title="四、如何配置死信队列"></a>四、如何配置死信队列</h2><p>这一部分将是本文的关键，如何配置死信队列呢？其实很简单，大概可以分为以下步骤：</p>
<ol>
<li>配置业务队列，绑定到业务交换机上</li>
<li>为业务队列配置死信交换机和路由key</li>
<li>为死信交换机配置死信队列</li>
</ol>
<p>注意，并不是直接声明一个公共的死信队列，然后所以死信消息就自己跑到死信队列里去了。而是为每个需要使用死信的业务队列配置一个死信交换机，这里同一个项目的死信交换机可以共用一个，然后为每个业务队列分配一个单独的路由key。</p>
<p>有了死信交换机和路由key后，接下来，就像配置业务队列一样，配置死信队列，然后绑定在死信交换机上。也就是说，死信队列并不是什么特殊的队列，只不过是绑定在死信交换机上的队列。死信交换机也不是什么特殊的交换机，只不过是用来接受死信的交换机，所以可以为任何类型【Direct、Fanout、Topic】。一般来说，会为每个业务队列分配一个独有的路由key，并对应的配置一个死信队列进行监听，也就是说，一般会为每个重要的业务队列配置一个死信队列。</p>
<p>有了前文这些陈述后，接下来就是惊险刺激的实战环节，这里省略了RabbitMQ环境的部署和搭建环节。</p>
<p>先创建一个Springboot项目。然后在pom文件中添加 <code>spring-boot-starter-amqp</code> 和 <code>spring-boot-starter-web</code> 的依赖，接下来创建一个Config类，这里是关键：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUSINESS_EXCHANGE_NAME = <span class="string">&quot;dead.letter.demo.simple.business.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUSINESS_QUEUEA_NAME = <span class="string">&quot;dead.letter.demo.simple.business.queuea&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUSINESS_QUEUEB_NAME = <span class="string">&quot;dead.letter.demo.simple.business.queueb&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_LETTER_EXCHANGE = <span class="string">&quot;dead.letter.demo.simple.deadletter.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_LETTER_QUEUEA_ROUTING_KEY = <span class="string">&quot;dead.letter.demo.simple.deadletter.queuea.routingkey&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_LETTER_QUEUEB_ROUTING_KEY = <span class="string">&quot;dead.letter.demo.simple.deadletter.queueb.routingkey&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_LETTER_QUEUEA_NAME = <span class="string">&quot;dead.letter.demo.simple.deadletter.queuea&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEAD_LETTER_QUEUEB_NAME = <span class="string">&quot;dead.letter.demo.simple.deadletter.queueb&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明业务Exchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;businessExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">businessExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(BUSINESS_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信Exchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;deadLetterExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">deadLetterExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(DEAD_LETTER_EXCHANGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明业务队列A</span></span><br><span class="line">    <span class="meta">@Bean(&quot;businessQueueA&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">businessQueueA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//       x-dead-letter-exchange    这里声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_LETTER_EXCHANGE);</span><br><span class="line"><span class="comment">//       x-dead-letter-routing-key  这里声明当前队列的死信路由key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, DEAD_LETTER_QUEUEA_ROUTING_KEY);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(BUSINESS_QUEUEA_NAME).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明业务队列B</span></span><br><span class="line">    <span class="meta">@Bean(&quot;businessQueueB&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">businessQueueB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//       x-dead-letter-exchange    这里声明当前队列绑定的死信交换机</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_LETTER_EXCHANGE);</span><br><span class="line"><span class="comment">//       x-dead-letter-routing-key  这里声明当前队列的死信路由key</span></span><br><span class="line">        args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, DEAD_LETTER_QUEUEB_ROUTING_KEY);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(BUSINESS_QUEUEB_NAME).withArguments(args).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列A</span></span><br><span class="line">    <span class="meta">@Bean(&quot;deadLetterQueueA&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">deadLetterQueueA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(DEAD_LETTER_QUEUEA_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列B</span></span><br><span class="line">    <span class="meta">@Bean(&quot;deadLetterQueueB&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">deadLetterQueueB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(DEAD_LETTER_QUEUEB_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明业务队列A绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">businessBindingA</span><span class="params">(<span class="meta">@Qualifier(&quot;businessQueueA&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="meta">@Qualifier(&quot;businessExchange&quot;)</span> FanoutExchange exchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明业务队列B绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">businessBindingB</span><span class="params">(<span class="meta">@Qualifier(&quot;businessQueueB&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="meta">@Qualifier(&quot;businessExchange&quot;)</span> FanoutExchange exchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列A绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">deadLetterBindingA</span><span class="params">(<span class="meta">@Qualifier(&quot;deadLetterQueueA&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="meta">@Qualifier(&quot;deadLetterExchange&quot;)</span> DirectExchange exchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEA_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明死信队列B绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">deadLetterBindingB</span><span class="params">(<span class="meta">@Qualifier(&quot;deadLetterQueueB&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="meta">@Qualifier(&quot;deadLetterExchange&quot;)</span> DirectExchange exchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(DEAD_LETTER_QUEUEB_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里声明了两个Exchange，一个是业务Exchange，另一个是死信Exchange，业务Exchange下绑定了两个业务队列，业务队列都配置了同一个死信Exchange，并分别配置了路由key，在死信Exchange下绑定了两个死信队列，设置的路由key分别为业务队列里配置的路由key。</p>
<p>下面是配置文件application.yml：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">simple</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">          <span class="attr">default-requeue-rejected:</span> <span class="literal">false</span></span><br><span class="line">          <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure>
<p>这里记得将<code>default-requeue-rejected</code>属性设置为false。</p>
<p>接下来，是业务队列的消费代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessMessageReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = BUSINESS_QUEUEA_NAME)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveA</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;收到业务消息A：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">        <span class="keyword">boolean</span> ack = <span class="keyword">true</span>;</span><br><span class="line">        Exception exception = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg.contains(<span class="string">&quot;deadletter&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;dead letter exception&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            ack = <span class="keyword">false</span>;</span><br><span class="line">            exception = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ack)&#123;</span><br><span class="line">            log.error(<span class="string">&quot;消息消费发生异常，error msg:&#123;&#125;&quot;</span>, exception.getMessage(), exception);</span><br><span class="line">            channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = BUSINESS_QUEUEB_NAME)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveB</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到业务消息B：&quot;</span> + <span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后配置死信队列的消费者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLetterMessageReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = DEAD_LETTER_QUEUEA_NAME)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveA</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到死信消息A：&quot;</span> + <span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = DEAD_LETTER_QUEUEB_NAME)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveB</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到死信消息B：&quot;</span> + <span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，为了方便测试，写一个简单的消息生产者，并通过controller层来生产消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessMessageSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        rabbitTemplate.convertSendAndReceive(BUSINESS_EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;rabbitmq&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQMsgController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BusinessMessageSender sender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;sendmsg&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        sender.sendMsg(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一切准备就绪，启动！</p>
<p>可以从RabbitMQ的管理后台中看到一共有四个队列，除默认的Exchange外还有声明的两个Exchange。</p>
<p>![8(%(3A_Y`_N8XX8W5XHZMWY.png](<a target="_blank" rel="noopener" href="https://i.loli.net/2019/07/14/5d2ae72753a8e90481.png">https://i.loli.net/2019/07/14/5d2ae72753a8e90481.png</a>)</p>
<p><img src="https://i.loli.net/2019/07/14/5d2ae792598f781012.png" alt="123.png"></p>
<p>接下来，访问一下url，来测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;rabbitmq&#x2F;sendmsg?msg&#x3D;msg</span><br></pre></td></tr></table></figure>
<p>日志：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">收到业务消息A：msg</span><br><span class="line">收到业务消息B：msg</span><br></pre></td></tr></table></figure>
<p>表示两个Consumer都正常收到了消息。这代表正常消费的消息，ack后正常返回。然后我们再来测试nck的消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;rabbitmq&#x2F;sendmsg?msg&#x3D;deadletter</span><br></pre></td></tr></table></figure>
<p>这将会触发业务队列A的NCK，按照预期，消息被NCK后，会抛到死信队列中，因此死信队列将会出现这个消息，日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">收到业务消息A：deadletter</span><br><span class="line">消息消费发生异常，error msg:dead letter exception</span><br><span class="line">java.lang.RuntimeException: dead letter exception</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">收到死信消息A：deadletter</span><br></pre></td></tr></table></figure>
<p>可以看到，死信队列的Consumer接受到了这个消息，所以流程到此为止就打通了。</p>
<h2 id="五、死信消息的变化"><a href="#五、死信消息的变化" class="headerlink" title="五、死信消息的变化"></a>五、死信消息的变化</h2><p>那么“死信”被丢到死信队列中后，会发生什么变化呢？</p>
<p>如果队列配置了参数 <code>x-dead-letter-routing-key</code> 的话，“死信”的路由key将会被替换成该参数对应的值。如果没有设置，则保留该消息原有的路由key。</p>
<p>举个栗子：</p>
<p>如果原有消息的路由key是<code>testA</code>，被发送到业务Exchage中，然后被投递到业务队列QueueA中，如果该队列没有配置参数<code>x-dead-letter-routing-key</code>，则该消息成为死信后，将保留原有的路由key<code>testA</code>，如果配置了该参数，并且值设置为<code>testB</code>，那么该消息成为死信后，路由key将会被替换为<code>testB</code>，然后被抛到死信交换机中。</p>
<p>另外，由于被抛到了死信交换机，所以消息的Exchange Name也会被替换为死信交换机的名称。</p>
<p>消息的Header中，也会添加很多奇奇怪怪的字段，修改一下上面的代码，在死信队列的消费者中添加一行日志输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">&quot;死信消息properties：&#123;&#125;&quot;</span>, message.getMessageProperties());</span><br></pre></td></tr></table></figure>
<p>然后重新运行一次，即可得到死信消息Header中被添加的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">死信消息properties：MessageProperties [headers&#x3D;&#123;x-first-death-exchange&#x3D;dead.letter.demo.simple.business.exchange, x-death&#x3D;[&#123;reason&#x3D;rejected, count&#x3D;1, exchange&#x3D;dead.letter.demo.simple.business.exchange, time&#x3D;Sun Jul 14 16:48:16 CST 2019, routing-keys&#x3D;[], queue&#x3D;dead.letter.demo.simple.business.queuea&#125;], x-first-death-reason&#x3D;rejected, x-first-death-queue&#x3D;dead.letter.demo.simple.business.queuea&#125;, correlationId&#x3D;1, replyTo&#x3D;amq.rabbitmq.reply-to.g2dkABZyYWJiaXRAREVTS1RPUC1DUlZGUzBOAAAPQAAAAAAB.bLbsdR1DnuRSwiKKmtdOGw&#x3D;&#x3D;, contentType&#x3D;text&#x2F;plain, contentEncoding&#x3D;UTF-8, contentLength&#x3D;0, receivedDeliveryMode&#x3D;PERSISTENT, priority&#x3D;0, redelivered&#x3D;false, receivedExchange&#x3D;dead.letter.demo.simple.deadletter.exchange, receivedRoutingKey&#x3D;dead.letter.demo.simple.deadletter.queuea.routingkey, deliveryTag&#x3D;1, consumerTag&#x3D;amq.ctag-NSp18SUPoCNvQcoYoS2lPg, consumerQueue&#x3D;dead.letter.demo.simple.deadletter.queuea]</span><br></pre></td></tr></table></figure>
<p>Header中看起来有很多信息，实际上并不多，只是值比较长而已。下面就简单说明一下Header中的值：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>x-first-death-exchange</td>
<td>第一次被抛入的死信交换机的名称</td>
</tr>
<tr>
<td>x-first-death-reason</td>
<td>第一次成为死信的原因，<code>rejected</code>：消息在重新进入队列时被队列拒绝，由于<code>default-requeue-rejected</code> 参数被设置为<code>false</code>。<code>expired</code>  ：消息过期。<code>maxlen</code> ： 队列内消息数量超过队列最大容量</td>
</tr>
<tr>
<td>x-first-death-queue</td>
<td>第一次成为死信前所在队列名称</td>
</tr>
<tr>
<td>x-death</td>
<td>历次被投入死信交换机的信息列表，同一个消息每次进入一个死信交换机，这个数组的信息就会被更新</td>
</tr>
</tbody></table>
<h2 id="六、死信队列应用场景"><a href="#六、死信队列应用场景" class="headerlink" title="六、死信队列应用场景"></a>六、死信队列应用场景</h2><p>通过上面的信息，我们已经知道如何使用死信队列了，那么死信队列一般在什么场景下使用呢？</p>
<p>一般用在较为重要的业务队列中，确保未被正确消费的消息不被丢弃，一般发生消费异常可能原因主要有由于消息信息本身存在错误导致处理异常，处理过程中参数校验异常，或者因网络波动导致的查询异常等等，当发生异常时，当然不能每次通过日志来获取原消息，然后让运维帮忙重新投递消息（没错，以前就是这么干的= =）。通过配置死信队列，可以让未正确处理的消息暂存到另一个队列中，待后续排查清楚问题后，编写相应的处理代码来处理死信消息，这样比手工恢复数据要好太多了。</p>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>死信队列其实并没有什么神秘的地方，不过是绑定在死信交换机上的普通队列，而死信交换机也只是一个普通的交换机，不过是用来专门处理死信的交换机。</p>
<p>总结一下死信消息的生命周期：</p>
<ol>
<li>业务消息被投入业务队列</li>
<li>消费者消费业务队列的消息，由于处理过程中发生异常，于是进行了nck或者reject操作</li>
<li>被nck或reject的消息由RabbitMQ投递到死信交换机中</li>
<li>死信交换机将消息投入相应的死信队列</li>
<li>死信队列的消费者消费死信消息</li>
</ol>
<p>死信消息是RabbitMQ为我们做的一层保证，其实我们也可以不使用死信队列，而是在消息消费异常时，将消息主动投递到另一个交换机中，当你明白了这些之后，这些Exchange和Queue想怎样配合就能怎么配合。比如从死信队列拉取消息，然后发送邮件、短信、钉钉通知来通知开发人员关注。或者将消息重新投递到一个队列然后设置过期时间，来进行延时消费。</p>
<p>如果本文对你有帮助，记得点个赞，也希望能分享给更多的朋友。也欢迎关注我的公众号进行留言交流。</p>
<p><img src="https://i.loli.net/2019/07/14/5d2af6692a8f432182.png" alt="TIM图片20190714173105.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://good19961106.github.io/2020/05/04/rabbitmq/rabbitmq-how-to-use-dead-letter-queue/" data-id="ckjjnjndr003ya8wcd2y35ith" data-title="【RabbitMQ】一文带你搞定RabbitMQ死信队列" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breeze-blog/tags/RabbitMQ/" rel="tag">RabbitMQ</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-rabbitmq/rabbitmq-how-to-ensure-reliable-delivery-of-message2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/breeze-blog/2020/05/04/rabbitmq/rabbitmq-how-to-ensure-reliable-delivery-of-message2/" class="article-date">
  <time class="dt-published" datetime="2020-05-03T16:00:30.000Z" itemprop="datePublished">2020-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/breeze-blog/categories/%E7%BC%96%E7%A8%8B/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/breeze-blog/2020/05/04/rabbitmq/rabbitmq-how-to-ensure-reliable-delivery-of-message2/">【RabbitMQ】如何进行消息可靠投递【下篇】</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>上一篇文章里，我们了解了如何保证消息被可靠投递到<em>RabbitMQ</em>的交换机中，但还有一些不完美的地方，试想一下，如果向RabbitMQ服务器发送一条消息，服务器确实也接收到了这条消息，于是给你返回了ACK确认消息，但服务器拿到这条消息一看，找不到路由它的队列，于是就把它丢进了垃圾桶，emmm，我猜应该属于可回收垃圾。</p>
<p><img src="https://i.loli.net/2019/08/22/nmPFS3RkIMweEXc.png" alt="1"></p>
<h2 id="如何让消息可靠投递到队列"><a href="#如何让消息可靠投递到队列" class="headerlink" title="如何让消息可靠投递到队列"></a>如何让消息可靠投递到队列</h2><p>如果你对上面的描述还不是很清楚，那我再用代码来说明一次。</p>
<p>在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如果发现该消息不可路由，那么消息会被直接丢弃，此时，生产者是不知道消息被丢弃这个事件的。</p>
<p>我们将上一篇中的交换机类型改为<em>DirectExchange</em>，这样就只有当消息的 <em>RoutingKey</em> 和队列绑定时设置的 <em>Bindingkey</em> （这里即“key”）一致时，才会真正将该消息进行路由。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUSINESS_EXCHANGE_NAME = <span class="string">&quot;rabbitmq.tx.demo.simple.business.exchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUSINESS_QUEUEA_NAME = <span class="string">&quot;rabbitmq.tx.demo.simple.business.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明业务 Exchange</span></span><br><span class="line"><span class="meta">@Bean(&quot;businessExchange&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DirectExchange <span class="title">businessExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(BUSINESS_EXCHANGE_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明业务队列</span></span><br><span class="line"><span class="meta">@Bean(&quot;businessQueue&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">businessQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(BUSINESS_QUEUEA_NAME).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明业务队列绑定关系</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">businessBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;businessQueue&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="meta">@Qualifier(&quot;businessExchange&quot;)</span> DirectExchange exchange)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对消息生产者也稍作修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//        rabbitTemplate.setChannelTransacted(true);</span></span><br><span class="line">    rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendCustomMsg</span><span class="params">(String exchange, String msg)</span> </span>&#123;</span><br><span class="line">    CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;消息id:&#123;&#125;, msg:&#123;&#125;&quot;</span>, correlationData.getId(), msg);</span><br><span class="line"></span><br><span class="line">    rabbitTemplate.convertAndSend(exchange, <span class="string">&quot;key&quot;</span>, msg, correlationData);</span><br><span class="line"></span><br><span class="line">    correlationData = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;消息id:&#123;&#125;, msg:&#123;&#125;&quot;</span>, correlationData.getId(), msg);</span><br><span class="line"></span><br><span class="line">    rabbitTemplate.convertAndSend(exchange, <span class="string">&quot;key2&quot;</span>, msg, correlationData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> b, String s)</span> </span>&#123;</span><br><span class="line">    String id = correlationData != <span class="keyword">null</span> ? correlationData.getId() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (b) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;消息确认成功, id:&#123;&#125;&quot;</span>, id);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;消息未成功投递, id:&#123;&#125;, cause:&#123;&#125;&quot;</span>, id, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们调用该方法，发送两条消息测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">消息id:ba6bf502-<span class="number">9381</span>-<span class="number">4220</span>-8dc9-313d6a289a4e, msg:<span class="number">1</span></span><br><span class="line">消息id:f0040a41-dc02-<span class="number">4e45</span>-b8af-e3cfa8a118b2, msg:<span class="number">1</span></span><br><span class="line">消息确认成功, id:ba6bf502-<span class="number">9381</span>-<span class="number">4220</span>-8dc9-313d6a289a4e</span><br><span class="line">消息确认成功, id:f0040a41-dc02-<span class="number">4e45</span>-b8af-e3cfa8a118b2</span><br><span class="line">收到业务消息：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可以看到，发送了两条消息，第一条消息的 <em>RoutingKey</em> 为 “key”，第二条消息的 RoutingKey 为 “key2”，两条消息都成功被交换机接收，也收到了交换机的确认回调，但消费者只收到了一条消息，因为第二条消息的 <em>RoutingKey</em> 与队列的 <em>BindingKey</em> 不一致，也没有其它队列能接收这个消息，所有第二条消息被直接丢弃了。</p>
<p>那么，如何让消息被路由到队列后再返回ACK呢？或者无法被路由的消息帮我想办法处理一下？最起码通知我一声，我好自己处理啊。</p>
<p>别慌别慌，<em>RabbitMQ</em>里有两个机制刚好可以解决我们上面的疑问：</p>
<p>1、mandatory 参数<br>2、备份交换机</p>
<h2 id="mandatory-参数"><a href="#mandatory-参数" class="headerlink" title="mandatory 参数"></a>mandatory 参数</h2><p>设置 <em>mandatory</em> 参数可以在当消息传递过程中不可达目的地时将消息返回给生产者。</p>
<p>当把 <em>mandotory</em> 参数设置为 true 时，如果交换机无法将消息进行路由时，会将该消息返回给生产者，而如果该参数设置为false，如果发现消息无法进行路由，则直接丢弃。</p>
<p><img src="https://i.loli.net/2019/09/01/YZ8acG1HxKQ9fLN.png" alt="2.png"></p>
<p>那么如何设置这个参数呢？在发送消息的时候，只需要在初始化方法添加一行代码即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>开启之后我们再重新运行前面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">消息id:19729f33-15c4-4c1b-8d48-044c301e2a8e, msg:<span class="number">1</span></span><br><span class="line">消息id:4aea5c57-<span class="number">3e71</span>-4a7b-8a00-1595d2b568eb, msg:<span class="number">1</span></span><br><span class="line">消息确认成功, id:19729f33-15c4-4c1b-8d48-044c301e2a8e</span><br><span class="line">Returned message but no callback available</span><br><span class="line">消息确认成功, id:4aea5c57-<span class="number">3e71</span>-4a7b-8a00-1595d2b568eb</span><br><span class="line">收到业务消息：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>我们看到中间多了一行提示 <code>Returned message but no callback available</code> 这是什么意思呢？</p>
<p>我们上面提到，设置 <em>mandatory</em> 参数后，如果消息无法被路由，则会返回给生产者，是通过回调的方式进行的，所以，生产者需要设置相应的回调函数才能接受该消息。</p>
<p>为了进行回调，我们需要实现一个接口 <code>RabbitTemplate.ReturnCallback</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessMsgProducer</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span>, <span class="title">RabbitTemplate</span>.<span class="title">ReturnCallback</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">        rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br><span class="line">        rabbitTemplate.setReturnCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendCustomMsg</span><span class="params">(String exchange, String msg)</span> </span>&#123;</span><br><span class="line">        CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;消息id:&#123;&#125;, msg:&#123;&#125;&quot;</span>, correlationData.getId(), msg);</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.convertAndSend(exchange, <span class="string">&quot;key&quot;</span>, msg, correlationData);</span><br><span class="line"></span><br><span class="line">        correlationData = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;消息id:&#123;&#125;, msg:&#123;&#125;&quot;</span>, correlationData.getId(), msg);</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.convertAndSend(exchange, <span class="string">&quot;key2&quot;</span>, msg, correlationData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> b, String s)</span> </span>&#123;</span><br><span class="line">        String id = correlationData != <span class="keyword">null</span> ? correlationData.getId() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (b) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;消息确认成功, id:&#123;&#125;&quot;</span>, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(<span class="string">&quot;消息未成功投递, id:&#123;&#125;, cause:&#123;&#125;&quot;</span>, id, s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;消息被服务器退回。msg:&#123;&#125;, replyCode:&#123;&#125;. replyText:&#123;&#125;, exchange:&#123;&#125;, routingKey :&#123;&#125;&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> String(message.getBody()), replyCode, replyText, exchange, routingKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们再来重新运行一次：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">消息id:2e5c336a-883a-474e-b40e-b6e3499088ef, msg:<span class="number">1</span></span><br><span class="line">消息id:85c771cb-c88f-47dd-adea-f0da57138423, msg:<span class="number">1</span></span><br><span class="line">消息确认成功, id:2e5c336a-883a-474e-b40e-b6e3499088ef</span><br><span class="line">消息无法被路由，被服务器退回。msg:<span class="number">1</span>, replyCode:<span class="number">312.</span> replyText:NO_ROUTE, exchange:rabbitmq.tx.demo.simple.business.exchange, routingKey :key2</span><br><span class="line">消息确认成功, id:85c771cb-c88f-47dd-adea-f0da57138423</span><br><span class="line">收到业务消息：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可以看到，我们接收到了被退回的消息，并带上了消息被退回的原因：<code>NO_ROUTE</code>。但是要注意的是， <em>mandatory</em> 参数仅仅是在当消息无法被路由的时候，让生产者可以感知到这一点，只要开启了生产者确认机制，无论是否设置了 <em>mandatory</em> 参数，都会在交换机接收到消息时进行消息确认回调，而且通常消息的返回回调会在消息的确认回调之前。</p>
<h2 id="备份交换机"><a href="#备份交换机" class="headerlink" title="备份交换机"></a>备份交换机</h2><p>有了 <em>mandatory</em> 参数，我们获得了对无法投递消息的感知能力，有机会在生产者的消息无法被投递时发现并处理。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然后触发报警，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。</p>
<p>而且设置 <em>mandatory</em> 参数会增加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的复杂性，该怎么做呢？</p>
<p>前面在设置死信队列的文章中，我们提到，可以为队列设置死信交换机来存储那些处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。</p>
<p>不要慌，在 RabbitMQ 中，有一种备份交换机的机制存在，可以很好的应对这个问题。</p>
<p>什么是备份交换机呢？备份交换机可以理解为 <em>RabbitMQ</em> 中交换机的“备胎”，当我们为某一个交换机声明一个对应的备份交换机时，就是为它创建一个备胎，当交换机接收到一条不可路由消息时，将会将这条消息转发到备份交换机中，由备份交换机来进行转发和处理，通常备份交换机的类型为 <em>Fanout</em> ，这样就能把所有消息都投递到与其绑定的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都进入这个队列了。当然，我们还可以建立一个报警队列，用独立的消费者来进行监测和报警。</p>
<p>听的不太明白？没关系，看个图就知道是怎么回事了。</p>
<p><img src="https://i.loli.net/2019/09/01/VsGpZJbk2u7wSv4.png" alt="3.png"></p>
<p>（emmm，调整了一下配色，感觉还是很丑- - 。急需一个UI来拯救我。）</p>
<p>接下来，我们就来设置一下备份交换机：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUSINESS_EXCHANGE_NAME = <span class="string">&quot;rabbitmq.backup.test.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUSINESS_QUEUE_NAME = <span class="string">&quot;rabbitmq.backup.test.queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUSINESS_BACKUP_EXCHANGE_NAME = <span class="string">&quot;rabbitmq.backup.test.backup-exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUSINESS_BACKUP_QUEUE_NAME = <span class="string">&quot;rabbitmq.backup.test.backup-queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUSINESS_BACKUP_WARNING_QUEUE_NAME = <span class="string">&quot;rabbitmq.backup.test.backup-warning-queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明业务 Exchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;businessExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">businessExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ExchangeBuilder exchangeBuilder = ExchangeBuilder.directExchange(BUSINESS_EXCHANGE_NAME)</span><br><span class="line">                .durable(<span class="keyword">true</span>)</span><br><span class="line">                .withArgument(<span class="string">&quot;alternate-exchange&quot;</span>, BUSINESS_BACKUP_EXCHANGE_NAME);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (DirectExchange)exchangeBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明备份 Exchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;backupExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">backupExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ExchangeBuilder exchangeBuilder = ExchangeBuilder.fanoutExchange(BUSINESS_BACKUP_EXCHANGE_NAME)</span><br><span class="line">                .durable(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> (FanoutExchange)exchangeBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明业务队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;businessQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">businessQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(BUSINESS_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明业务队列绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">businessBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;businessQueue&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="meta">@Qualifier(&quot;businessExchange&quot;)</span> DirectExchange exchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明备份队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;backupQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">backupQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(BUSINESS_BACKUP_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明报警队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;warningQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">warningQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(BUSINESS_BACKUP_WARNING_QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明备份队列绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">backupBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;backupQueue&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange exchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明备份报警队列绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">backupWarningBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;warningQueue&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange exchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们使用 <code>ExchangeBuilder</code> 来声明交换机，并为其设置备份交换机：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.withArgument(<span class="string">&quot;alternate-exchange&quot;</span>, BUSINESS_BACKUP_EXCHANGE_NAME);</span><br></pre></td></tr></table></figure>
<p>为业务交换机绑定了一个队列，为备份交换机绑定了两个队列，一个专门用来做报警用途。</p>
<p>接下来，分别为业务交换机和备份交换机创建消费者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessMsgConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = BUSINESS_QUEUE_NAME)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;收到业务消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">        channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessWaringConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = BUSINESS_BACKUP_WARNING_QUEUE_NAME)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.error(<span class="string">&quot;发现不可路由消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们分别发送一条可路由消息和不可路由消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessMsgProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendCustomMsg</span><span class="params">(String exchange, String msg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;消息id:&#123;&#125;, msg:&#123;&#125;&quot;</span>, correlationData.getId(), msg);</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.convertAndSend(exchange, <span class="string">&quot;key&quot;</span>, msg, correlationData);</span><br><span class="line"></span><br><span class="line">        correlationData = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;消息id:&#123;&#125;, msg:&#123;&#125;&quot;</span>, correlationData.getId(), msg);</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.convertAndSend(exchange, <span class="string">&quot;key2&quot;</span>, msg, correlationData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">消息id:5c3a33c9-<span class="number">0764</span>-4d1f-bf6a-a00d771dccb4, msg:<span class="number">1</span></span><br><span class="line">消息id:42ac8c35-1d0a-<span class="number">4413</span>-a1df-c26a85435354, msg:<span class="number">1</span></span><br><span class="line">收到业务消息：<span class="number">1</span></span><br><span class="line">发现不可路由消息：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这里仅仅使用 <em>error</em> 日志配合日志系统进行报警，如果是敏感数据，可以使用邮件、钉钉、短信、电话等报警方式来提高时效性。</p>
<p>那么问题来了，<em>mandatory</em> 参数与备份交换机可以一起使用吗？设置 <em>mandatory</em> 参数会让交换机将不可路由消息退回给生产者，而备份交换机会让交换机将不可路由消息转发给它，那么如果两者同时开启，消息究竟何去何从？？</p>
<p>emmm，想这么多干嘛，试试不就知道了。</p>
<p>修改一下生产者即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessMsgProducer</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span>, <span class="title">RabbitTemplate</span>.<span class="title">ReturnCallback</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        rabbitTemplate.setChannelTransacted(true);</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">        rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br><span class="line">        rabbitTemplate.setReturnCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendCustomMsg</span><span class="params">(String exchange, String msg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;消息id:&#123;&#125;, msg:&#123;&#125;&quot;</span>, correlationData.getId(), msg);</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.convertAndSend(exchange, <span class="string">&quot;key&quot;</span>, msg, correlationData);</span><br><span class="line"></span><br><span class="line">        correlationData = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;消息id:&#123;&#125;, msg:&#123;&#125;&quot;</span>, correlationData.getId(), msg);</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.convertAndSend(exchange, <span class="string">&quot;key2&quot;</span>, msg, correlationData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> b, String s)</span> </span>&#123;</span><br><span class="line">        String id = correlationData != <span class="keyword">null</span> ? correlationData.getId() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (b) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;消息确认成功, id:&#123;&#125;&quot;</span>, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(<span class="string">&quot;消息未成功投递, id:&#123;&#125;, cause:&#123;&#125;&quot;</span>, id, s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;消息被服务器退回。msg:&#123;&#125;, replyCode:&#123;&#125;. replyText:&#123;&#125;, exchange:&#123;&#125;, routingKey :&#123;&#125;&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> String(message.getBody()), replyCode, replyText, exchange, routingKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来测试一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">消息id:0a3eca1e-d937-418c-a7ce-bfb8ce25fdd4, msg:<span class="number">1</span></span><br><span class="line">消息id:d8c9e010-e120-46da-a42e-1ba21026ff06, msg:<span class="number">1</span></span><br><span class="line">消息确认成功, id:0a3eca1e-d937-418c-a7ce-bfb8ce25fdd4</span><br><span class="line">消息确认成功, id:d8c9e010-e120-46da-a42e-1ba21026ff06</span><br><span class="line">发现不可路由消息：<span class="number">1</span></span><br><span class="line">收到业务消息：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可以看到，两条消息都可以收到确认成功回调，但是不可路由消息不会被回退给生产者，而是直接转发给备份交换机。可见备份交换机的处理优先级更高。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上一篇中，我们介绍了事务机制和生产者确认机制来确保消息的可靠投递，相对而言，生产者确认机制更加高效和灵活。本篇中，我们介绍了另外两种确保生产者的消息不丢失的机制，即通过 mandatory 参数和备份交换机来处理不可路由消息。</p>
<p>通过以上几种机制，我们总算是可以确保消息被万无一失的投递到目的地了。到此，我们的消息可靠投递也就告一段落了。消息可靠投递是我们使用MQ时无法逃避的话题，一次性搞定它，就不会再为其所困。总的来说，方法总比问题多，但如果你不知道这些方法，那么当问题来临时，也许就会不知所措了。</p>
<p>相信通过这几篇关于 <em>RabbitMQ</em> 文章的学习，对于 <em>RabbitMQ</em> 的理解已经突破天际，那还在等什么，赶紧把接入 <em>RabbitMQ</em> 的项目好好优化一下吧，相信现在你就不会再被那些不知所云的配置和代码所迷惑了。</p>
<p>到此为止，本篇就完美落幕了，希望能给你带来一些启发，也欢迎关注我的公众号进行留言交流。</p>
<p><img src="https://i.loli.net/2019/08/11/8MxBPNgyIlTZDRk.png" alt="1565529015677.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://good19961106.github.io/2020/05/04/rabbitmq/rabbitmq-how-to-ensure-reliable-delivery-of-message2/" data-id="ckjjnjndq003va8wc0tjj4lh1" data-title="【RabbitMQ】如何进行消息可靠投递【下篇】" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breeze-blog/tags/RabbitMQ/" rel="tag">RabbitMQ</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-rabbitmq/rabbitmq-how-to-ensure-reliable-delivery-of-message" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/breeze-blog/2020/05/04/rabbitmq/rabbitmq-how-to-ensure-reliable-delivery-of-message/" class="article-date">
  <time class="dt-published" datetime="2020-05-03T16:00:20.000Z" itemprop="datePublished">2020-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/breeze-blog/categories/%E7%BC%96%E7%A8%8B/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/breeze-blog/2020/05/04/rabbitmq/rabbitmq-how-to-ensure-reliable-delivery-of-message/">【RabbitMQ】如何进行消息可靠投递【上篇】</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>前几天，突然发生线上报警，钉钉连发了好几条消息，一看是<em>RabbitMQ</em>相关的消息，心头一紧，难道翻车了？</p>
<p><img src="https://i.loli.net/2019/08/19/o3ZELv7GkRImstJ.jpg" alt="u=1091165172,1855706818&amp;fm=26&amp;gp=0.jpg"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[橙色报警] 应用[xxx]在[08-<span class="number">15</span> <span class="number">16</span>:<span class="number">36</span>:<span class="number">04</span>]发生[错误日志异常]，alertId=[xxx]。由[org.springframework.amqp.rabbit.listener.BlockingQueueConsumer:start:<span class="number">620</span>]触发。</span><br><span class="line">应用xxx 可能原因如下</span><br><span class="line">服务名为：</span><br><span class="line"> 异常为：org.springframework.amqp.rabbit.listener.BlockingQueueConsumer:start:<span class="number">620</span></span><br><span class="line"> 产生原因如下:</span><br><span class="line"><span class="number">1.</span>org.springframework.amqp.rabbit.listener.QueuesNotAvailableException: Cannot prepare queue <span class="keyword">for</span> listener. Either the queue doesn<span class="string">&#x27;t exist or the broker will not allow us to use it.</span></span><br><span class="line"><span class="string">||Consumer received fatal=false exception on startup:</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">应用xxx 可能原因如下</span></span><br><span class="line"><span class="string">服务名为：</span></span><br><span class="line"><span class="string"> 异常为：org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer$AsyncMessageProcessingConsumer:run:1160</span></span><br><span class="line"><span class="string"> 产生原因如下:</span></span><br><span class="line"><span class="string">1.Stopping container from aborted consumer||Stopping container from aborted consumer:</span></span><br></pre></td></tr></table></figure>
<p>定睛一看，看样子像是消费者莫名其妙断开了连接，正逢公司搬家之际，难道是机房又双叒叕。。。。断电了？于是赶紧联系了运维，咨询<em>RabbitMQ</em>是否发生了调整。几分钟后，得到了运维的回复，由于一些不可描述的原因，<em>RabbitMQ</em>进行了重启，emmmm，虽然重启只持续了10分钟，但是导致该集群下所有消费者都挂了，需要将项目重启后才能正常进行消费。</p>
<p>项目重启后，一切似乎又正常运转起来，但好景不长，没过多久，工单就找上了门来，经过排查，发现是生产者在<em>RabbitMQ</em>重启期间消息投递失败，导致消息丢失，需要手动处理和恢复。</p>
<p>于是，我开始思考，如何才能进行<em>RabbitMQ</em>的消息可靠投递呢？特别是在这样比较极端的情况，<em>RabbitMQ</em>集群不可用的时候，无法投递的消息该如何处理呢？</p>
<h2 id="可靠投递"><a href="#可靠投递" class="headerlink" title="可靠投递"></a>可靠投递</h2><p>先来说明一个概念，什么是可靠投递呢？在<em>RabbitMQ</em>中，一个消息从生产者发送到<em>RabbitMQ</em>服务器，需要经历这么几个步骤：</p>
<ol>
<li>生产者准备好需要投递的消息。</li>
<li>生产者与<em>RabbitMQ</em>服务器建立连接。</li>
<li>生产者发送消息。</li>
<li><em>RabbitMQ</em>服务器接收到消息，并将其路由到指定队列。</li>
<li><em>RabbitMQ</em>服务器发起回调，告知生产者消息发送成功。</li>
</ol>
<p>所谓可靠投递，就是确保消息能够百分百从生产者发送到服务器。</p>
<p><img src="https://i.loli.net/2019/08/18/yHcfoILDmTh7qbd.jpg" alt="{6582FAF9-A46E-4239-810B-E1D6883ED070}.png.jpg"></p>
<p>为了避免争议，补充说明一下，如果没有设置<em>Mandatory</em>参数，是不需要先路由消息才发起回调的，服务器收到消息后就会进行回调确认。</p>
<p>2、3、5步都是通过<em>TCP</em>连接进行交互，有网络调用的地方就会有事故，网络波动随时都有可能发生，不管是内部机房停电，还是外部光缆被切，网络事故无法预测，虽然这些都是小概率事件，但对于订单等敏感数据处理来说，这些情况下导致消息丢失都是不可接受的。</p>
<p><img src="https://i.loli.net/2019/08/19/Fwp87UqONIKCZsJ.jpg" alt="20170716034945131.jpg"></p>
<h2 id="RabbitMQ中的消息可靠投递"><a href="#RabbitMQ中的消息可靠投递" class="headerlink" title="RabbitMQ中的消息可靠投递"></a>RabbitMQ中的消息可靠投递</h2><p>默认情况下，发送消息的操作是不会返回任何信息给生产者的，也就是说，默认情况下生产者是不知道消息有没有正确地到达服务器。</p>
<p>那么如何解决这个问题呢？</p>
<p>对此，<em>RabbitMQ</em>中有一些相关的解决方案：</p>
<ol>
<li>使用事务机制来让生产者感知消息被成功投递到服务器。</li>
<li>通过生产者确认机制实现。</li>
</ol>
<p>在<em>RabbitMQ</em>中，所有确保消息可靠投递的机制都会对性能产生一定影响，如使用不当，可能会对吞吐量造成重大影响，只有通过执行性能基准测试，才能在确定性能与可靠投递之间的平衡。</p>
<p>在使用可靠投递前，需要先思考以下问题：</p>
<ol>
<li>消息发布时，保证消息进入队列的重要性有多高？</li>
<li>如果消息无法进行路由，是否应该将该消息返回给发布者？</li>
<li>如果消息无法被路由，是否应该将其发送到其他地方稍后再重新进行路由？</li>
<li>如果<em>RabbitMQ</em>服务器崩溃了，是否可以接受消息丢失？</li>
<li><em>RabbitMQ</em>在处理新消息时是否应该确认它已经为发布者执行了所有请求的路由和持久化？</li>
<li>消息发布者是否可以批量投递消息？</li>
<li>在可靠投递上是否有可以接受的平衡性？是否可以接受一部分的不可靠性来提升性能？</li>
</ol>
<p>只考虑平衡性不考虑性能是不行的，至于这个平衡的度具体如何把握，就要具体情况具体分析了，比如像订单数据这样敏感的信息，对可靠性的要求自然要比一般的业务消息对可靠性的要求高的多，因为订单数据是跟钱直接相关的，可能会导致直接的经济损失。</p>
<p>所以不仅应该知道有哪些保证消息可靠性的解决方案，还应该知道每种方案对性能的影响程度，以此来进行方案的选择。</p>
<h3 id="RabbitMQ的事务机制"><a href="#RabbitMQ的事务机制" class="headerlink" title="RabbitMQ的事务机制"></a>RabbitMQ的事务机制</h3><p><em>RabbitMQ</em>是支持<em>AMQP</em>事务机制的，在生产者确认机制之前，事务是确保消息被成功投递的唯一方法。</p>
<p>在<em>SpringBoot</em>项目中，使用<em>RabbitMQ</em>事务其实很简单，只需要声明一个事务管理的<em>Bean</em>，并将<em>RabbitTemplate</em>的事务设置为true即可。</p>
<p>配置文件如下：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">simple</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">default-requeue-rejected:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure>
<p>先来配置一下交换机和队列，以及事务管理器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUSINESS_EXCHANGE_NAME = <span class="string">&quot;rabbitmq.tx.demo.simple.business.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUSINESS_QUEUEA_NAME = <span class="string">&quot;rabbitmq.tx.demo.simple.business.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明业务Exchange</span></span><br><span class="line">    <span class="meta">@Bean(&quot;businessExchange&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">businessExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(BUSINESS_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明业务队列</span></span><br><span class="line">    <span class="meta">@Bean(&quot;businessQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">businessQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(BUSINESS_QUEUEA_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明业务队列绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">businessBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;businessQueue&quot;)</span> Queue queue,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="meta">@Qualifier(&quot;businessExchange&quot;)</span> FanoutExchange exchange)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置启用rabbitmq事务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connectionFactory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RabbitTransactionManager <span class="title">rabbitTransactionManager</span><span class="params">(CachingConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RabbitTransactionManager(connectionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后创建一个消费者，来监听消息，用以判断消息是否成功发送。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessMsgConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = BUSINESS_QUEUEA_NAME)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveMsg</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String msg = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;收到业务消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">        channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是消息生产者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessMsgProducer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.setChannelTransacted(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(BUSINESS_EXCHANGE_NAME, <span class="string">&quot;key&quot;</span>, msg);</span><br><span class="line">        <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.contains(<span class="string">&quot;exception&quot;</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;surprise!&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;消息已发送 &#123;&#125;&quot;</span> ,msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有两个注意的地方：</p>
<ol>
<li>在初始化方法里，通过使用<code> rabbitTemplate.setChannelTransacted(true);</code> 来开启事务。</li>
<li>在发送消息的方法上加上 <code>@Transactional</code> 注解，这样在该方法中发生异常时，消息将不会发送。</li>
</ol>
<p>在controller中加一个接口来生产消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BusinessMsgProducer producer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;send&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        producer.sendMsg(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来验证一下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">msg:1</span><br><span class="line">消息已发送 1</span><br><span class="line">收到业务消息：1</span><br><span class="line">msg:2</span><br><span class="line">消息已发送 2</span><br><span class="line">收到业务消息：2</span><br><span class="line">msg:3</span><br><span class="line">消息已发送 3</span><br><span class="line">收到业务消息：3</span><br><span class="line">msg:exception</span><br><span class="line"></span><br><span class="line">Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.RuntimeException: surprise!] with root cause</span><br><span class="line"></span><br><span class="line">java.lang.RuntimeException: surprise!</span><br><span class="line">	at com.mfrank.rabbitmqdemo.producer.BusinessMsgProducer.sendMsg(BusinessMsgProducer.java:30)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>当 <code>msg</code> 的值为 <code>exception</code> 时， 在调用<code>rabbitTemplate.convertAndSend</code> 方法之后，程序抛出了异常，消息并没有发送出去，而是被当前事务回滚了。</p>
<p>当然，你可以将事务管理器注释掉，或者将初始化方法的开启事务注释掉，这样事务就不会生效，即使在调用了发送消息方法之后，程序发生了异常，消息也会被正常发送和消费。</p>
<p>RabbitMQ中的事务使用起来虽然简单，但是对性能的影响是不可忽视的，因为每次事务的提交都是阻塞式的等待服务器处理返回结果，而默认模式下，客户端是不需要等待的，直接发送就完事了，除此之外，事务消息需要比普通消息多4次与服务器的交互，这就意味着会占用更多的处理时间，所以如果对消息处理速度有较高要求时，尽量不要采用事务机制。</p>
<h3 id="RabbitMQ的生产者确认机制"><a href="#RabbitMQ的生产者确认机制" class="headerlink" title="RabbitMQ的生产者确认机制"></a>RabbitMQ的生产者确认机制</h3><p><em>RabbitMQ</em>中的生产者确认功能是<em>AMQP</em>规范的增强功能，当生产者发布给所有队列的已路由消息被消费者应用程序直接消费时，或者消息被放入队列并根据需要进行持久化时，一个<em>Basic.Ack</em>请求会被发送到生产者，如果消息无法路由，代理服务器将发送一个<em>Basic.Nack</em> RPC请求用于表示失败。然后由生产者决定该如何处理该消息。</p>
<p>也就是说，通过生产者确认机制，生产者可以在消息被服务器成功接收时得到反馈，并有机会处理未被成功接收的消息。</p>
<p>在Springboot中开启RabbitMQ的生产者确认模式也很简单，只多了一行配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">simple</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">default-requeue-rejected:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br><span class="line">    <span class="attr">publisher-confirms:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><code> publisher-confirms: true</code> 即表示开启生产者确认模式。</p>
<p>然后将消息生产者的代表进行部分修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessMsgProducer</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        rabbitTemplate.setChannelTransacted(true);</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendCustomMsg</span><span class="params">(String exchange, String msg)</span> </span>&#123;</span><br><span class="line">        CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;消息id:&#123;&#125;, msg:&#123;&#125;&quot;</span>, correlationData.getId(), msg);</span><br><span class="line"></span><br><span class="line">        rabbitTemplate.convertAndSend(exchange, <span class="string">&quot;key&quot;</span>, msg, correlationData);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> b, String s)</span> </span>&#123;</span><br><span class="line">        String id = correlationData != <span class="keyword">null</span> ? correlationData.getId() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (b) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;消息确认成功, id:&#123;&#125;&quot;</span>, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(<span class="string">&quot;消息未成功投递, id:&#123;&#125;, cause:&#123;&#125;&quot;</span>, id, s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让生产者继承自<code>RabbitTemplate.ConfirmCallback</code> 类，然后实现其<code>confirm</code> 方法，即可用其接收服务器回调。</p>
<p>需要注意的是，在发送消息时，代码也进行了调整：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line"></span><br><span class="line">rabbitTemplate.convertAndSend(exchange, <span class="string">&quot;key&quot;</span>, msg, correlationData);</span><br></pre></td></tr></table></figure>
<p>这里我们为消息设置了消息ID，以便在回调时通过该ID来判断是对哪个消息的回调，因为在回调函数中，我们是无法直接获取到消息内容的，所以需要将消息先暂存起来，根据消息的重要程度，可以考虑使用本地缓存，或者存入<em>Redis</em>中，或者<em>Mysql</em>中，然后在回调时更新其状态或者从缓存中移除，最后使用定时任务对一段时间内未发送的消息进行重新投递。</p>
<p>以下是我盗来的图，原谅我偷懒不想画了[手动狗头]：</p>
<p><img src="https://i.loli.net/2019/08/19/CO5bs2xwh4WHFpM.png" alt="5b65729e0001439305000294.jpg"></p>
<p>另外，还需要注意的是，如果将消息发布到不存在的交换机上，那么发布用的信道将会被<em>RabbitMQ</em>关闭。</p>
<p>此外，生产者确认机制跟事务是不能一起工作的，是事务的轻量级替代方案。因为事务和发布者确认模式都是需要先跟服务器协商，对信道启用的一种模式，不能对同一个信道同时使用两种模式。</p>
<p>在生产者确认模式中，消息的确认可以是异步和批量的，所以相比使用事务，性能会更好。</p>
<p>使用事务机制和生产者确认机制都能确保消息被正确的发送至<em>RabbitMQ</em>，这里的“正确发送至RabbitMQ”说的是消息成功被交换机接收，但如果找不到能接收该消息的队列，这条消息也会丢失。至于如何处理那些无法被投递到队列的消息，将会在下篇进行说明。</p>
<h2 id="结题"><a href="#结题" class="headerlink" title="结题"></a>结题</h2><p>所以当公司机房“断电”时，如何处理那些需要发送的消息呢？相信看完上文之后，你的心中已经有了答案。</p>
<p>一般来说，这种“断电”不会持续较长时间，一般几分钟到半小时之间，很快能够恢复，所以如果是重要消息，可以保存到数据库中，如果是非重要消息，可以使用<em>redis</em>进行保存，当然，还要根据消息的数量级来进行判断。</p>
<p>如果消息量比较大，可以考虑将消息发送到另一个集群的死信队列中，事实上，所在公司就有两个<em>RabbitMQ</em>集群，所以当一个集群不可用时，可以往另一个集群发消息，emmm，如果两个机房都停电了的话，当我没说。</p>
<p><img src="https://i.loli.net/2019/08/19/c8ZGAL7OEPQTeWM.jpg" alt="111.png.jpg"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://good19961106.github.io/2020/05/04/rabbitmq/rabbitmq-how-to-ensure-reliable-delivery-of-message/" data-id="ckjjnjncc000ma8wcgehs49qe" data-title="【RabbitMQ】如何进行消息可靠投递【上篇】" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breeze-blog/tags/RabbitMQ/" rel="tag">RabbitMQ</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-best-practice/how-to-retry-elegantly" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/breeze-blog/2020/05/04/best-practice/how-to-retry-elegantly/" class="article-date">
  <time class="dt-published" datetime="2020-05-03T16:00:10.000Z" itemprop="datePublished">2020-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/breeze-blog/categories/%E7%BC%96%E7%A8%8B/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/breeze-blog/2020/05/04/best-practice/how-to-retry-elegantly/">【最佳实践】如何优雅的进行重试</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文口味：冰镇杨梅           预计阅读：20分钟</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>最近公司在搞活动，需要依赖一个第三方接口，测试阶段并没有什么异常状况，但上线后发现依赖的接口有时候会因为内部错误而返回系统异常，虽然概率不大，但总因为这个而报警总是不好的，何况死信队列的消息还需要麻烦运维进行重新投递，所以加上重试机制势在必行。</p>
<p>重试机制可以保护系统减少因网络波动、依赖服务短暂性不可用带来的影响，让系统能更稳定的运行的一种保护机制。让你原本就稳如狗的系统更是稳上加稳。</p>
<p><img src="https://i.loli.net/2019/08/04/eAUjdRTgskmWF3f.png" alt="1"></p>
<p>为了方便说明，先假设我们想要进行重试的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicLong helloTimes = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> times = helloTimes.incrementAndGet();</span><br><span class="line">        <span class="keyword">if</span> (times % <span class="number">4</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            log.warn(<span class="string">&quot;发生异常，time：&#123;&#125;&quot;</span>, LocalTime.now() );</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HelloRetryException(<span class="string">&quot;发生Hello异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用处：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloRetryService</span> <span class="keyword">implements</span> <span class="title">IHelloService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloService.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，这个接口每调4次才会成功一次。</p>
<h2 id="手动重试"><a href="#手动重试" class="headerlink" title="手动重试"></a>手动重试</h2><p>先来用最简单的方法，直接在调用的时候进重试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动重试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxRetryTimes = <span class="number">4</span>;</span><br><span class="line">    String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> retry = <span class="number">1</span>; retry &lt;= maxRetryTimes; retry++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s = helloService.hello();</span><br><span class="line">            log.info(<span class="string">&quot;helloService返回:&#123;&#125;&quot;</span>, s);</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (HelloRetryException e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;helloService.hello() 调用失败，准备重试&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HelloRetryException(<span class="string">&quot;重试次数耗尽&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">发生异常，time：10:17:21.079413300</span><br><span class="line">helloService.hello() 调用失败，准备重试</span><br><span class="line">发生异常，time：10:17:21.085861800</span><br><span class="line">helloService.hello() 调用失败，准备重试</span><br><span class="line">发生异常，time：10:17:21.085861800</span><br><span class="line">helloService.hello() 调用失败，准备重试</span><br><span class="line">helloService返回:hello</span><br><span class="line">service.helloRetry()：hello</span><br></pre></td></tr></table></figure>
<p>程序在极短的时间内进行了4次重试，然后成功返回。</p>
<p>这样虽然看起来可以解决问题，但实践上，由于没有重试间隔，很可能当时依赖的服务尚未从网络异常中恢复过来，所以极有可能接下来的几次调用都是失败的。</p>
<p>而且，这样需要对代码进行大量的侵入式修改，显然，不优雅。</p>
<p><img src="https://i.loli.net/2019/08/04/ABwDil3xTFaIfyu.png" alt="3.png"></p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>上面的处理方式由于需要对业务代码进行大量修改，虽然实现了功能，但是对原有代码的侵入性太强，可维护性差。</p>
<p>所以需要使用一种更优雅一点的方式，不直接修改业务代码，那要怎么做呢？</p>
<p>其实很简单，直接在业务代码的外面再包一层就行了，代理模式在这里就有用武之地了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloRetryProxyService</span> <span class="keyword">implements</span> <span class="title">IHelloService</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloRetryService helloRetryService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxRetryTimes = <span class="number">4</span>;</span><br><span class="line">        String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> retry = <span class="number">1</span>; retry &lt;= maxRetryTimes; retry++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                s = helloRetryService.hello();</span><br><span class="line">                log.info(<span class="string">&quot;helloRetryService 返回:&#123;&#125;&quot;</span>, s);</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (HelloRetryException e) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;helloRetryService.hello() 调用失败，准备重试&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HelloRetryException(<span class="string">&quot;重试次数耗尽&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，重试逻辑就都由代理类来完成，原业务类的逻辑就不需要修改了，以后想修改重试逻辑也只需要修改这个类就行了，分工明确。比如，现在想要在重试之间加上一个延迟，只需要做一点点修改即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxRetryTimes = <span class="number">4</span>;</span><br><span class="line">    String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> retry = <span class="number">1</span>; retry &lt;= maxRetryTimes; retry++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s = helloRetryService.hello();</span><br><span class="line">            log.info(<span class="string">&quot;helloRetryService 返回:&#123;&#125;&quot;</span>, s);</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (HelloRetryException e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;helloRetryService.hello() 调用失败，准备重试&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 延时一秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HelloRetryException(<span class="string">&quot;重试次数耗尽&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理模式虽然要更加优雅，但是如果依赖的服务很多的时候，要为每个服务都创建一个代理类，显然过于麻烦，而且其实重试的逻辑都大同小异，无非就是重试的次数和延时不一样而已。如果每个类都写这么一长串类似的代码，显然，不优雅！</p>
<p><img src="https://i.loli.net/2019/08/04/z6JxEGdhUK9y1YW.png" alt="4.png"></p>
<h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>这时候，动态代理就闪亮登场了。只需要写一个代理处理类，就可以开局一条狗，砍到九十九。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RetryInvocationHandler</span><span class="params">(Object subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (times &lt; RetryConstant.MAX_TIMES) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(subject, args);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                times++;</span><br><span class="line">                log.info(<span class="string">&quot;times:&#123;&#125;,time:&#123;&#125;&quot;</span>, times, LocalTime.now());</span><br><span class="line">                <span class="keyword">if</span> (times &gt;= RetryConstant.MAX_TIMES) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 延时一秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取动态代理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> realSubject 代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Object realSubject)</span> </span>&#123;</span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> RetryInvocationHandler(realSubject);</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(handler.getClass().getClassLoader(),</span><br><span class="line">                realSubject.getClass().getInterfaces(), handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来一发单元测：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloDynamicProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IHelloService realService = <span class="keyword">new</span> HelloService();</span><br><span class="line">    IHelloService proxyService = (IHelloService)RetryInvocationHandler.getProxy(realService);</span><br><span class="line"></span><br><span class="line">    String hello = proxyService.hello();</span><br><span class="line">    log.info(<span class="string">&quot;hello:&#123;&#125;&quot;</span>, hello);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hello times:1</span><br><span class="line">发生异常，time：11:22:20.727586700</span><br><span class="line">times:1,time:11:22:20.728083</span><br><span class="line">hello times:2</span><br><span class="line">发生异常，time：11:22:21.728858700</span><br><span class="line">times:2,time:11:22:21.729343700</span><br><span class="line">hello times:3</span><br><span class="line">发生异常，time：11:22:22.729706600</span><br><span class="line">times:3,time:11:22:22.729706600</span><br><span class="line">hello times:4</span><br><span class="line">hello:hello</span><br></pre></td></tr></table></figure>
<p>在重试了4次之后输出了<code>Hello</code>，符合预期。</p>
<p>动态代理可以将重试逻辑都放到一块，显然比直接使用代理类要方便很多，也更加优雅。</p>
<p>不过不要高兴的太早，这里因为被代理的<em>HelloService</em>是一个简单的类，没有依赖其它类，所以直接创建是没有问题的，但如果被代理的类依赖了其它被<em>Spring</em>容器管理的类，则这种方式会抛出异常，因为没有把被依赖的实例注入到创建的代理实例中。</p>
<p>这种情况下，就比较复杂了，需要从<em>Spring</em>容器中获取已经装配好的，需要被代理的实例，然后为其创建代理类实例，并交给<em>Spring</em>容器来管理，这样就不用每次都重新创建新的代理类实例了。</p>
<p>话不多说，撸起袖子就是干。</p>
<p><img src="https://i.loli.net/2019/08/11/w8R6EAGCtkneQhI.jpg" alt="timg.jpg"></p>
<p>新建一个工具类，用来获取代理实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryProxyHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ConfigurableApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 从Bean中获取对象</span></span><br><span class="line">        DefaultListableBeanFactory beanFactory = (DefaultListableBeanFactory)context.getAutowireCapableBeanFactory();</span><br><span class="line">        Map&lt;String, Object&gt; beans = beanFactory.getBeansOfType(clazz);</span><br><span class="line">        Set&lt;Map.Entry&lt;String, Object&gt;&gt; entries = beans.entrySet();</span><br><span class="line">        <span class="keyword">if</span> (entries.size() &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ProxyBeanNotFoundException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有多个候选bean, 判断其中是否有代理bean</span></span><br><span class="line">        Object bean = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (entries.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : entries) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry.getKey().contains(PROXY_BEAN_SUFFIX))&#123;</span><br><span class="line">                    bean = entry.getValue();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">if</span> (bean != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> bean;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ProxyBeanNotSingleException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object source = beans.entrySet().iterator().next().getValue();</span><br><span class="line">        Object source = beans.entrySet().iterator().next().getValue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 判断该对象的代理对象是否存在</span></span><br><span class="line">        String proxyBeanName = clazz.getSimpleName() + PROXY_BEAN_SUFFIX;</span><br><span class="line">        Boolean exist = beanFactory.containsBean(proxyBeanName);</span><br><span class="line">        <span class="keyword">if</span> (exist) &#123;</span><br><span class="line">            bean = beanFactory.getBean(proxyBeanName);</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 不存在则生成代理对象</span></span><br><span class="line">        bean = RetryInvocationHandler.getProxy(source);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 将bean注入spring容器</span></span><br><span class="line">        beanFactory.registerSingleton(proxyBeanName, bean);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的是<code>JDK动态代理</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RetryInvocationHandler</span><span class="params">(Object subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (times &lt; RetryConstant.MAX_TIMES) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(subject, args);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                times++;</span><br><span class="line">                log.info(<span class="string">&quot;retry times:&#123;&#125;,time:&#123;&#125;&quot;</span>, times, LocalTime.now());</span><br><span class="line">                <span class="keyword">if</span> (times &gt;= RetryConstant.MAX_TIMES) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 延时一秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取动态代理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> realSubject 代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Object realSubject)</span> </span>&#123;</span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> RetryInvocationHandler(realSubject);</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(handler.getClass().getClassLoader(),</span><br><span class="line">                realSubject.getClass().getInterfaces(), handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，主要代码就完成了，修改一下<em>HelloService</em>类，增加一个依赖：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> <span class="keyword">implements</span> <span class="title">IHelloService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicLong helloTimes = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> NameService nameService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> times = helloTimes.incrementAndGet();</span><br><span class="line">        log.info(<span class="string">&quot;hello times:&#123;&#125;&quot;</span>, times);</span><br><span class="line">        <span class="keyword">if</span> (times % <span class="number">4</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            log.warn(<span class="string">&quot;发生异常，time：&#123;&#125;&quot;</span>, LocalTime.now() );</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HelloRetryException(<span class="string">&quot;发生Hello异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + nameService.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>NameService</em>其实很简单，创建的目的仅在于测试依赖注入的<em>Bean</em>能否正常运行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Frank&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来一发测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloJdkProxy</span><span class="params">()</span> <span class="keyword">throws</span> InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">    IHelloService proxy = (IHelloService) retryProxyHandler.getProxy(HelloService.class);</span><br><span class="line">    String hello = proxy.hello();</span><br><span class="line">    log.info(<span class="string">&quot;hello:&#123;&#125;&quot;</span>, hello);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hello times:1</span><br><span class="line">发生异常，time：14:40:27.540672200</span><br><span class="line">retry times:1,time:14:40:27.541167400</span><br><span class="line">hello times:2</span><br><span class="line">发生异常，time：14:40:28.541584600</span><br><span class="line">retry times:2,time:14:40:28.542033500</span><br><span class="line">hello times:3</span><br><span class="line">发生异常，time：14:40:29.542161500</span><br><span class="line">retry times:3,time:14:40:29.542161500</span><br><span class="line">hello times:4</span><br><span class="line">hello:hello Frank</span><br></pre></td></tr></table></figure>
<p>完美，这样就不用担心依赖注入的问题了，因为从<em>Spring</em>容器中拿到的<em>Bean</em>对象都是已经注入配置好的。当然，这里仅考虑了单例<em>Bean</em>的情况，可以考虑的更加完善一点，判断一下容器中<em>Bean</em>的类型是Singleton还是<em>Prototype</em>，如果是<em>Singleton</em>则像上面这样进行操作，如果是<em>Prototype</em>则每次都新建代理类对象。</p>
<p>另外，这里使用的是<code>JDK动态代理</code>，因此就存在一个天然的缺陷，如果想要被代理的类，没有实现任何接口，那么就无法为其创建代理对象，这种方式就行不通了。</p>
<p><img src="https://i.loli.net/2019/08/11/GzmFVto59SLMgOl.jpg" alt="EDaBTlbkyvbhmng.jpg"></p>
<h2 id="CGLib-动态代理"><a href="#CGLib-动态代理" class="headerlink" title="CGLib 动态代理"></a>CGLib 动态代理</h2><p>既然已经说到了<code>JDK动态代理</code>，那就不得不提<code>CGLib动态代理</code>了。使用<code>JDK动态代理</code>对被代理的类有要求，不是所有的类都能被代理，而<code>CGLib动态代理</code>则刚好解决了这个问题。</p>
<p>创建一个<code>CGLib动态代理</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibRetryProxyHandler</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;<span class="comment">//需要代理的目标对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写拦截方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] arr, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (times &lt; RetryConstant.MAX_TIMES) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(target, arr);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                times++;</span><br><span class="line">                log.info(<span class="string">&quot;cglib retry :&#123;&#125;,time:&#123;&#125;&quot;</span>, times, LocalTime.now());</span><br><span class="line">                <span class="keyword">if</span> (times &gt;= RetryConstant.MAX_TIMES) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 延时一秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义获取代理对象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getCglibProxy</span><span class="params">(Object objectTarget)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = objectTarget;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(objectTarget.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        Object result = enhancer.create();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想要换用<code>CGLib动态代理</code>，替换一下这两行代码即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 不存在则生成代理对象</span></span><br><span class="line"><span class="comment">//        bean = RetryInvocationHandler.getProxy(source);</span></span><br><span class="line">CGLibRetryProxyHandler proxyHandler = <span class="keyword">new</span> CGLibRetryProxyHandler();</span><br><span class="line">bean = proxyHandler.getCglibProxy(source);</span><br></pre></td></tr></table></figure>
<p>开始测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloCGLibProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IHelloService proxy = (IHelloService) retryProxyHandler.getProxy(HelloService.class);</span><br><span class="line">    String hello = proxy.hello();</span><br><span class="line">    log.info(<span class="string">&quot;hello:&#123;&#125;&quot;</span>, hello);</span><br><span class="line"></span><br><span class="line">    hello = proxy.hello();</span><br><span class="line">    log.info(<span class="string">&quot;hello:&#123;&#125;&quot;</span>, hello);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">hello times:1</span><br><span class="line">发生异常，time：15:06:00.799679100</span><br><span class="line">cglib retry :1,time:15:06:00.800175400</span><br><span class="line">hello times:2</span><br><span class="line">发生异常，time：15:06:01.800848600</span><br><span class="line">cglib retry :2,time:15:06:01.801343100</span><br><span class="line">hello times:3</span><br><span class="line">发生异常，time：15:06:02.802180</span><br><span class="line">cglib retry :3,time:15:06:02.802180</span><br><span class="line">hello times:4</span><br><span class="line">hello:hello Frank</span><br><span class="line">hello times:5</span><br><span class="line">发生异常，time：15:06:03.803933800</span><br><span class="line">cglib retry :1,time:15:06:03.803933800</span><br><span class="line">hello times:6</span><br><span class="line">发生异常，time：15:06:04.804945400</span><br><span class="line">cglib retry :2,time:15:06:04.805442</span><br><span class="line">hello times:7</span><br><span class="line">发生异常，time：15:06:05.806886500</span><br><span class="line">cglib retry :3,time:15:06:05.807881300</span><br><span class="line">hello times:8</span><br><span class="line">hello:hello Frank</span><br></pre></td></tr></table></figure>
<p>这样就很棒了，完美的解决了<code>JDK动态代理</code>带来的缺陷。优雅指数上涨了不少。</p>
<p>但这个方案仍旧存在一个问题，那就是需要对原来的逻辑进行侵入式修改，在每个被代理实例被调用的地方都需要进行调整，这样仍然会对原有代码带来较多修改。</p>
<p><img src="https://i.loli.net/2019/08/11/IczsWOdt4PL6vom.jpg" alt="fuuTyTbkyvbhmsa.jpg"></p>
<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><p>想要无侵入式的修改原有逻辑？想要一个注解就实现重试？用<code>Spring AOP</code>不就能完美实现吗？使用<code>AOP</code>来为目标调用设置切面，即可在目标方法调用前后添加一些额外的逻辑。</p>
<p>先创建一个注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retryable &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">retryTimes</span><span class="params">()</span> <span class="keyword">default</span> 3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">retryInterval</span><span class="params">()</span> <span class="keyword">default</span> 1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有两个参数，<em>retryTimes</em> 代表最大重试次数，<em>retryInterval</em>代表重试间隔。</p>
<p>然后在需要重试的方法上加上注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retryable(retryTimes = 4, retryInterval = 2)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> times = helloTimes.incrementAndGet();</span><br><span class="line">    log.info(<span class="string">&quot;hello times:&#123;&#125;&quot;</span>, times);</span><br><span class="line">    <span class="keyword">if</span> (times % <span class="number">4</span> != <span class="number">0</span>)&#123;</span><br><span class="line">        log.warn(<span class="string">&quot;发生异常，time：&#123;&#125;&quot;</span>, LocalTime.now() );</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HelloRetryException(<span class="string">&quot;发生Hello异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + nameService.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，进行最后一步，编写<em>AOP</em>切面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.mfrank.springboot.retry.demo.annotation.Retryable)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">retryMethodCall</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;retryMethodCall()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">retry</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取重试次数和重试间隔</span></span><br><span class="line">        Retryable retry = ((MethodSignature)joinPoint.getSignature()).getMethod().getAnnotation(Retryable.class);</span><br><span class="line">        <span class="keyword">int</span> maxRetryTimes = retry.retryTimes();</span><br><span class="line">        <span class="keyword">int</span> retryInterval = retry.retryInterval();</span><br><span class="line"></span><br><span class="line">        Throwable error = <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> retryTimes = <span class="number">1</span>; retryTimes &lt;= maxRetryTimes; retryTimes++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object result = joinPoint.proceed();</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                error = throwable;</span><br><span class="line">                log.warn(<span class="string">&quot;调用发生异常，开始重试，retryTimes:&#123;&#125;&quot;</span>, retryTimes);</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(retryInterval * <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RetryExhaustedException(<span class="string">&quot;重试次数耗尽&quot;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开始测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> HelloService helloService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloAOP</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String hello = helloService.hello();</span><br><span class="line">    log.info(<span class="string">&quot;hello:&#123;&#125;&quot;</span>, hello);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hello times:1</span><br><span class="line">发生异常，time：16:49:30.224649800</span><br><span class="line">调用发生异常，开始重试，retryTimes:1</span><br><span class="line">hello times:2</span><br><span class="line">发生异常，time：16:49:32.225230800</span><br><span class="line">调用发生异常，开始重试，retryTimes:2</span><br><span class="line">hello times:3</span><br><span class="line">发生异常，time：16:49:34.225968900</span><br><span class="line">调用发生异常，开始重试，retryTimes:3</span><br><span class="line">hello times:4</span><br><span class="line">hello:hello Frank</span><br></pre></td></tr></table></figure>
<p>这样就相当优雅了，一个注解就能搞定重试，简直不要更棒。</p>
<p><img src="https://i.loli.net/2019/08/11/fOegoZhjwECGbA9.jpg" alt="IStGDBbkyvbhmow.jpg"></p>
<h2 id="Spring-的重试注解"><a href="#Spring-的重试注解" class="headerlink" title="Spring 的重试注解"></a>Spring 的重试注解</h2><p>实际上<em>Spring</em>中就有比较完善的重试机制，比上面的切面更加好用，还不需要自己动手重新造轮子。</p>
<p>那让我们先来看看这个轮子究竟好不好使。</p>
<p>先引入重试所需的jar包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.retry<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-retry<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在启动类或者配置类上添加*@EnableRetry<em>注解，接下来在需要重试的方法上添加</em>@Retryable*注解（嗯？好像跟我自定义的注解一样？竟然抄袭我的注解！ [手动滑稽] ） </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retryable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> times = helloTimes.incrementAndGet();</span><br><span class="line">    log.info(<span class="string">&quot;hello times:&#123;&#125;&quot;</span>, times);</span><br><span class="line">    <span class="keyword">if</span> (times % <span class="number">4</span> != <span class="number">0</span>)&#123;</span><br><span class="line">        log.warn(<span class="string">&quot;发生异常，time：&#123;&#125;&quot;</span>, LocalTime.now() );</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HelloRetryException(<span class="string">&quot;发生Hello异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + nameService.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，会重试三次，重试间隔为1秒。当然我们也可以自定义重试次数和间隔。这样就跟我前面实现的功能是一毛一样的了。</p>
<p>但<em>Spring</em>里的重试机制还支持很多很有用的特性，比如说，可以指定只对特定类型的异常进行重试，这样如果抛出的是其它类型的异常则不会进行重试，就可以对重试进行更细粒度的控制。默认为空，会对所有异常都重试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retryable</span>&#123;value = &#123;HelloRetryException.class&#125;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用<em>include</em>和<em>exclude</em>来指定包含或者排除哪些异常进行重试。</p>
<p>可以用<em>maxAttemps</em>指定最大重试次数，默认为3次。</p>
<p>可以用<em>interceptor</em>设置重试拦截器的bean名称。</p>
<p>可以通过<em>label</em>设置该重试的唯一标志，用于统计输出。</p>
<p>可以使用<em>exceptionExpression</em>来添加异常表达式，在抛出异常后执行，以判断后续是否进行重试。</p>
<p>此外，<em>Spring</em>中的重试机制还支持使用<em>backoff</em>来设置重试补偿机制，可以设置重试间隔，并且支持设置重试延迟倍数。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retryable(value = &#123;HelloRetryException.class&#125;, maxAttempts = 5,</span></span><br><span class="line"><span class="meta">           backoff = @Backoff(delay = 1000, multiplier = 2))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法调用将会在抛出<em>HelloRetryException</em>异常后进行重试，最大重试次数为5，第一次重试间隔为1s，之后以2倍大小进行递增，第二次重试间隔为2s，第三次为4s，第四次为8s。</p>
<p>重试机制还支持使用 <code>@Recover</code> 注解来进行善后工作，当重试达到指定次数之后，将会调用该方法，可以在该方法中进行日志记录等操作。</p>
<p>这里值得注意的是，想要 <code>@Recover</code> 注解生效的话，需要跟被 <code>@Retryable</code> 标记的方法在同一个类中，且被 <code>@Retryable</code> 标记的方法不能有返回值，否则不会生效。</p>
<p>并且如果使用了 <code>@Recover</code> 注解的话，重试次数达到最大次数后，如果在 <code>@Recover</code> 标记的方法中无异常抛出，是不会抛出原异常的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Recover</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recover</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">    log.error(<span class="string">&quot;达到最大重试次数&quot;</span>,e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了使用注解外，<code>Spring Retry</code> 也支持直接在调用时使用代码进行重试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">normalSpringRetry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表示哪些异常需要重试,key表示异常的字节码,value为true表示需要重试</span></span><br><span class="line">    Map&lt;Class&lt;? extends Throwable&gt;, Boolean&gt; exceptionMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    exceptionMap.put(HelloRetryException.class, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建重试模板实例</span></span><br><span class="line">    RetryTemplate retryTemplate = <span class="keyword">new</span> RetryTemplate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置重试回退操作策略，主要设置重试间隔时间</span></span><br><span class="line">    FixedBackOffPolicy backOffPolicy = <span class="keyword">new</span> FixedBackOffPolicy();</span><br><span class="line">    <span class="keyword">long</span> fixedPeriodTime = <span class="number">1000L</span>;</span><br><span class="line">    backOffPolicy.setBackOffPeriod(fixedPeriodTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置重试策略，主要设置重试次数</span></span><br><span class="line">    <span class="keyword">int</span> maxRetryTimes = <span class="number">3</span>;</span><br><span class="line">    SimpleRetryPolicy retryPolicy = <span class="keyword">new</span> SimpleRetryPolicy(maxRetryTimes, exceptionMap);</span><br><span class="line"></span><br><span class="line">    retryTemplate.setRetryPolicy(retryPolicy);</span><br><span class="line">    retryTemplate.setBackOffPolicy(backOffPolicy);</span><br><span class="line"></span><br><span class="line">    Boolean execute = retryTemplate.execute(</span><br><span class="line">        <span class="comment">//RetryCallback</span></span><br><span class="line">        retryContext -&gt; &#123;</span><br><span class="line">            String hello = helloService.hello();</span><br><span class="line">            log.info(<span class="string">&quot;调用的结果:&#123;&#125;&quot;</span>, hello);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// RecoverCallBack</span></span><br><span class="line">        retryContext -&gt; &#123;</span><br><span class="line">            <span class="comment">//RecoveryCallback</span></span><br><span class="line">            log.info(<span class="string">&quot;已达到最大重试次数&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时唯一的好处是可以设置多种重试策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NeverRetryPolicy：只允许调用RetryCallback一次，不允许重试</span><br><span class="line"></span><br><span class="line">AlwaysRetryPolicy：允许无限重试，直到成功，此方式逻辑不当会导致死循环</span><br><span class="line"></span><br><span class="line">SimpleRetryPolicy：固定次数重试策略，默认重试最大次数为<span class="number">3</span>次，RetryTemplate默认使用的策略</span><br><span class="line"></span><br><span class="line">TimeoutRetryPolicy：超时时间重试策略，默认超时时间为<span class="number">1</span>秒，在指定的超时时间内允许重试</span><br><span class="line"></span><br><span class="line">ExceptionClassifierRetryPolicy：设置不同异常的重试策略，类似组合重试策略，区别在于这里只区分不同异常的重试</span><br><span class="line"></span><br><span class="line">CircuitBreakerRetryPolicy：有熔断功能的重试策略，需设置<span class="number">3</span>个参数openTimeout、resetTimeout和delegate</span><br><span class="line"></span><br><span class="line">CompositeRetryPolicy：组合重试策略，有两种组合方式，乐观组合重试策略是指只要有一个策略允许即可以重试，</span><br><span class="line">悲观组合重试策略是指只要有一个策略不允许即可以重试，但不管哪种组合方式，组合中的每一个策略都会执行</span><br></pre></td></tr></table></figure>
<p>可以看出，<code>Spring</code> 中的重试机制还是相当完善的，比上面自己写的 <code>AOP</code> 切面功能更加强大。</p>
<p>这里还需要再提醒的一点是，由于<code>Spring Retry</code>用到了<code>Aspect</code>增强，所以就会有使用<code>Aspect</code>不可避免的坑——方法内部调用，如果被 <code>@Retryable</code> 注解的方法的调用方和被调用方处于同一个类中，那么重试将会失效。</p>
<p>但也还是存在一定的不足，<code>Spring</code>的重试机制只支持对异常进行捕获，而无法对返回值进行校验。</p>
<p><img src="https://i.loli.net/2019/08/11/9CuPZHtqMbpLA8a.jpg" alt="dtFxiMbkyvbhlzo.jpg"></p>
<h2 id="Guava-Retry"><a href="#Guava-Retry" class="headerlink" title="Guava Retry"></a>Guava Retry</h2><p>最后，再介绍另一个重试利器——<code>Guava Retry</code>。</p>
<p>相比<code>Spring Retry</code>，<code>Guava Retry</code>具有更强的灵活性，可以根据返回值校验来判断是否需要进行重试。</p>
<p>先来看一个小栗子：</p>
<p>先引入jar包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.rholder<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava-retrying<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后用一个小Demo来感受一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">guavaRetry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Retryer&lt;String&gt; retryer = RetryerBuilder.&lt;String&gt;newBuilder()</span><br><span class="line">        .retryIfExceptionOfType(HelloRetryException.class)</span><br><span class="line">        .retryIfResult(StringUtils::isEmpty)</span><br><span class="line">        .withWaitStrategy(WaitStrategies.fixedWait(<span class="number">3</span>, TimeUnit.SECONDS))</span><br><span class="line">        .withStopStrategy(StopStrategies.stopAfterAttempt(<span class="number">3</span>))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        retryer.call(() -&gt; helloService.hello());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先创建一个<em>Retryer</em>实例，然后使用这个实例对需要重试的方法进行调用，可以通过很多方法来设置重试机制，比如使用<em>retryIfException</em>来对所有异常进行重试，使用<em>retryIfExceptionOfType</em>方法来设置对指定异常进行重试，使用<em>retryIfResult</em>来对不符合预期的返回结果进行重试，使用<em>retryIfRuntimeException</em>方法来对所有<em>RuntimeException</em>进行重试。</p>
<p>还有五个以<em>with</em>开头的方法，用来对重试策略/等待策略/阻塞策略/单次任务执行时间限制/自定义监听器进行设置，以实现更加强大的异常处理。</p>
<p>通过跟 <code>Spring AOP</code> 的结合，可以实现比 <code>Spring Retry</code> 更加强大的重试功能。</p>
<p>仔细对比之下，<code>Guava Retry</code> 可以提供的特性有：</p>
<ol>
<li>可以设置任务单次执行的时间限制，如果超时则抛出异常。</li>
<li>可以设置重试监听器，用来执行额外的处理工作。</li>
<li>可以设置任务阻塞策略，即可以设置当前重试完成，下次重试开始前的这段时间做什么事情。</li>
<li>可以通过停止重试策略和等待策略结合使用来设置更加灵活的策略，比如指数等待时长并最多10次调用，随机等待时长并永不停止等等。</li>
</ol>
<p><img src="https://i.loli.net/2019/08/11/MFpbWwysvP6Zqo7.jpg" alt="GBvgTpbkyvbhlEB.jpg"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文由浅入深的对多种重试的姿势进行了360度无死角教学，从最简单的手动重试，到使用静态代理，再到 <code>JDK动态代理</code> 和 <code>CGLib动态代理</code> ，再到 <code>Spring AOP</code>，都是手工造轮子的过程，最后介绍了两种目前比较好用的轮子，一个是<code>Spring Retry</code>，使用起来简单粗暴，与 <code>Spring</code> 框架天生搭配，一个注解搞定所有事情，另一个便是 <code>Guava Retry</code>，不依赖于 <code>Spring</code> 框架，自成体系，使用起来更加灵活强大。</p>
<p>个人认为，大部分场景下，<code>Spring Retry</code> 提供的重试机制已经足够强大，如果不需要 <code>Guava Retry</code> 提供的额外灵活性，使用 <code>Spring Retry</code> 就很棒了。当然，具体情况具体分析，但没有必要的情况下，不鼓励重复造轮子，先把别人的轮子研究清楚再想想还用不用自己动手。</p>
<p>本文到此就告一段落了，又用了一天的时间完成了完成了一篇文章，写作的目的在于总结和分享，我相信最佳实践是可以总结和积累下来的，在大多数场景下都是适用的，这些最佳实践会在逐渐的积累过程中，成为比经验更为重要的东西。因为经验不总结就会忘记，而总结出来的内容却不会被丢失。</p>
<p>如果对于重试你有更好的想法，欢迎提出交流探讨，也欢迎关注我的公众号进行留言交流。</p>
<p><img src="https://i.loli.net/2019/08/11/8MxBPNgyIlTZDRk.png" alt="1565529015677.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://good19961106.github.io/2020/05/04/best-practice/how-to-retry-elegantly/" data-id="ckjjnjndo003pa8wc4c8e08iz" data-title="【最佳实践】如何优雅的进行重试" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breeze-blog/tags/Spring/" rel="tag">Spring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breeze-blog/tags/%E4%BC%98%E9%9B%85%E9%87%8D%E8%AF%95/" rel="tag">优雅重试</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breeze-blog/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" rel="tag">最佳实践</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-java/basic/java-class" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/breeze-blog/2020/05/04/java/basic/java-class/" class="article-date">
  <time class="dt-published" datetime="2020-05-03T15:25:05.000Z" itemprop="datePublished">2020-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/breeze-blog/categories/%E7%BC%96%E7%A8%8B/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/breeze-blog/2020/05/04/java/basic/java-class/">【Java基础篇】四、Java 类与对象</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Java-类与对象"><a href="#Java-类与对象" class="headerlink" title="Java 类与对象"></a>Java 类与对象</h1><blockquote>
<p><strong>“Sometimes we stare so long at a door that is closing that we see too late the one that is open.”</strong></p>
<p>— Alexander Graham Bell, Inventor</p>
<p><strong>「我们有时候专注于消失中的机会太久，以致于太晚发现开启的机会。」</strong>– 亚历山大‧贝尔 (发明家)</p>
</blockquote>
<h2 id="关卡说明"><a href="#关卡说明" class="headerlink" title="关卡说明"></a>关卡说明</h2><p>关卡描述：<code>Java</code> 是一门面向对象的语言，<code>类</code>和<code>对象</code>是 <code>Java</code> 中最重要的概念，本关将介绍这两个重要的概念，并通过一个简单的栗子来进行说明，你能否通过本关的考验呢？</p>
<p>过关条件：理解面向对象编程的特点，理解 <code>Java</code> 中<code>类</code>和<code>对象</code>的关系，以及如何使用它们</p>
<p>关卡难度：⭐️⭐️</p>
<h2 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h2><p><strong>面向对象编程</strong>（Object Oriented Programming 简称OOP）是当今主流的程序设计规范，<em>Java</em>是完全面向对象的，所以必须熟悉++OOP++才能编写出优秀的<em>Java</em>代码。</p>
<p><strong>面向对象编程</strong>，顾名思义，重点就在于这个对象，没有对象怎么编程（手动滑稽）。咳咳，言归正传，面向对象的程序是由许许多多的对象组成，每个对象具有一定的属性和行为，通过对象之间的交互来实现软件的功能。从根本上来说，只要这个对象能满足功能要求，就不必关心它的具体实现过程。换句话说，<strong>不管是黑猫白猫，能抓耗子的猫就是好猫</strong>。</p>
<p>传统的程序设计是面向过程编程，在传统的程序设计过程中，通常需要先设计一系列的算法来求解问题，然后再考虑存储数据的方式。这就是所谓的：</p>
<blockquote>
<p>算法 + 数据结构 = 程序</p>
</blockquote>
<p>在面向过程的设计中，算法是放在第一位的，数据结构是为了适应算法而存在的。</p>
<p>而在OOP中，这个顺序刚好相反，数据结构放在第一位，然后再考虑操作数据的算法。</p>
<p>两种开发方式各有利弊，一些简单的问题，使用面向过程的开发方式是比较容易的，因为它符合人们的惯常思考方式，先这样做，再那样做，最后得到一个什么样的结果。而面向对象的编程适合于解决更复杂的问题。比如实现一个网站也许需要1000个函数，这些过程可能会对一组全局的数据进行操作。如果采用面向对象的方式来设计，可能只需要大约100个类，每个类10个方法，而且大多数情况下，面向过程开发的代码中有很多设计是可以使用面向对象的方式简化和复用的。所以后者显然更容易掌握和维护，而且如果万一某个数据出了问题，在10个方法中排查总比在1000个函数中排查要容易得多。</p>
<h2 id="Java中的类和对象"><a href="#Java中的类和对象" class="headerlink" title="Java中的类和对象"></a>Java中的类和对象</h2><p>既然面向对象编程这么优秀，那么我们就来好好认识一下这其中的主人公——类和对象。</p>
<p>“类”是对具有相同属性的一系列事物的抽象，比如说，“人类”，描述的就是有“人”这个共同属性和行为的群体，普通的人都有两只手，两只脚等基本外貌特征，也具有说话，吃东西等能力，比如“轿车”描述的是有四个轮子，可以驾驶，可以载人的小型车辆，不管你是黑色的奔驰还是白色的宝马，都可以叫做轿车。</p>
<p>那么什么是对象呢？对象就是类的某个具体实例，就好比你和我都是“人类”的一个具体实例，所以我们都是“人类”的一个对象。你家车库里的那辆轿车（不管是奔驰还是大众），也是“轿车”的一个对象。</p>
<blockquote>
<p>类是抽象的概念，是对具有共同特征的事物的抽象，而对象则是具体的概念，是指某一个具体的实例。</p>
</blockquote>
<p>类可以看作是对象的模子，可以用它来生产任意多个对象。</p>
<h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>先来看一个小栗子，我们来定义一个人类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始吃饭...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我叫&quot;</span> + name + <span class="string">&quot;，我今年&quot;</span> + age + <span class="string">&quot;岁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们定义了一个类，类的名字叫做<code>Person</code>，它有两个属性，一个是<code>name</code>，一个是<code>age</code>。并且有三个方法，一个是构造函数，两个是Person的行为，吃饭和说话。</p>
<p>可以看到，定义类的时候，我们是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义类的格式为：</p>
<blockquote>
<p>[访问权限修饰符] + class + [类名] </p>
</blockquote>
<p>其中访问权限修饰符用来表示类是否可以被外部类访问，<code>public</code>是最宽松的访问权限，表示这个类可以被外部的类访问和使用。关于访问权限修饰符，后面还会有更详细的介绍。</p>
<p><code>class</code>是用来声明一个类的关键字。什么是关键字呢？可以理解为一种声明，就像武功招式一样，大都会有一个起手式。<code>Java</code> 中的关键字其实不多，常用的就更少，所以在之后的学习过程中慢慢掌握就好了，不用太担心。</p>
<p>关于类名，跟变量名一样，必须以字母开头，可以由字母、数字和下划线和$组成，但跟变量命名不同的是，Java中的类名规范通常使用大驼峰命名法，即每个单词的首字母都大写。比如：<em>SmallCar</em>、<em>SecondhandBook</em>。</p>
<h2 id="类的组成"><a href="#类的组成" class="headerlink" title="类的组成"></a>类的组成</h2><p>一个类主要由实例域和方法域组成，实例域由类的成员变量组成，上面的栗子中，Person类的实例域为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br></pre></td></tr></table></figure>
<p>这是Person类的两个成员变量，也叫Person类的属性，一个人有名字和年龄，在这里对应的两个属性就是<code>name</code>和<code>age</code>。</p>
<p>成员变量定义的规则为：</p>
<blockquote>
<p>[访问修饰符] + [成员变量类型] + [变量名]</p>
</blockquote>
<p>接下来是方法域，顾名思义便是由各种方法组成的。方法的定义规则为：</p>
<blockquote>
<p>[访问修饰符] + [方法返回值类型] + [方法名]</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;开始吃饭...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我叫&quot;</span> + name + <span class="string">&quot;，我今年&quot;</span> + age + <span class="string">&quot;岁&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，<code>void</code>表示当前方法无返回值。方法的命名跟变量的命名规则一样，也使用小驼峰命名法。需要注意的一点是，无论是类名、方法名还是变量名，都需要具有一定的意义，也就是要能够传达出它代表的含义，做到见名知义。像<code>a1</code>、<code>a2</code>这样的命名就尽量不要出现。</p>
<p>也许你会好奇，上面不是还有一个方法吗？为什看起来有点奇怪呢？为什么它不使用小驼峰，为什么它跟类名是一样的？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个好问题，它叫做<strong>构造函数</strong>，是创建变量时使用的一个特殊的方法，与类名同名。这个方法有两个参数，一个是<code>String</code>类型，一个是<code>int</code>类型，<code>name</code>和<code>age</code>是参数名，跟变量名类似。这里面还用了一个<code>this</code>关键字，代表当前对象，可以看到参数名跟上面的成员变量名相同，为了将它们区分开来，就使用了<code>this.name</code>和<code>this.age</code>来表示成员变量。这个方法的作用就是接收传进来的两个参数，并将它们分别赋值给成员变量。关于构造函数的具体作用会在之后的篇章里做说明，这里就先不详细介绍了。</p>
<h2 id="对象的创建和使用"><a href="#对象的创建和使用" class="headerlink" title="对象的创建和使用"></a>对象的创建和使用</h2><p>既然已经有了类，那么如何创建对象呢？这时候就需要使用新的招式——<code>new</code>关键字。下面我们在<em>Person</em>类中加入一个main方法（如果不记得<em>main</em>方法是干嘛的了，可以翻看一下上一篇的内容），并在其中创建一个<em>Person</em>对象并调用它的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person alice = <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        alice.say();</span><br><span class="line">        alice.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我叫Alice，我今年18岁</span><br><span class="line">开始吃饭...</span><br></pre></td></tr></table></figure>
<p>老规矩，我们来逐行分析，首先我们使用了<code>new</code>关键字创建了一个对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person alice = <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></figure>
<p>在前面我们已经介绍过变量的声明方式了，回顾一下：</p>
<blockquote>
<p>[类名] + [变量名]</p>
</blockquote>
<p><em>Person</em>是类名，<em>alice</em>是变量的名字，后面半段的作用是创建对象。往里面传了两个参数：<code>Alice</code>和<code>18</code>。创建好对象后，赋值给<em>alice</em>变量。</p>
<p>然后我们分别调用了两个方法，<code>say</code>和<code>eat</code>。方法调用的格式为：</p>
<blockquote>
<p>[对象] + 点号 + [方法名] + [参数]</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alice.say();</span><br><span class="line">alice.eat();</span><br></pre></td></tr></table></figure>
<p>这两个方法都不需要传参数，可以直接调用。这样，我们就完成了创建对象并调用的全过程。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇文章到此就告一段落了，本篇内容相对较多一点，而且也是相当重要的一篇，希望能仔细阅读，能通过本篇的学习了解类和对象是什么，以及如何使用。</p>
<p>也许到这里你还有很多疑惑，但没有关系，在之后的学习和练习的过程中，相信你会慢慢理解的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://good19961106.github.io/2020/05/04/java/basic/java-class/" data-id="ckjjnjncg000ua8wccukj700i" data-title="【Java基础篇】四、Java 类与对象" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breeze-blog/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breeze-blog/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-java/basic/java-variable" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/breeze-blog/2020/05/04/java/basic/java-variable/" class="article-date">
  <time class="dt-published" datetime="2020-05-03T15:25:04.000Z" itemprop="datePublished">2020-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/breeze-blog/categories/%E7%BC%96%E7%A8%8B/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/breeze-blog/2020/05/04/java/basic/java-variable/">【Java基础篇】三、Java 变量</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p><strong>“The superior man makes the difficulty to be overcome his first interest; success comes only later.”</strong></p>
<p>— William Jennings Bryan</p>
<p><strong>「优秀的人将克服困难当做第一优先，成功只是之后的附带品。」</strong>    – 威廉‧詹宁斯‧布莱恩 (政客)</p>
</blockquote>
<h2 id="关卡说明"><a href="#关卡说明" class="headerlink" title="关卡说明"></a>关卡说明</h2><p>关卡描述：变量是<em>Java</em>程序中最常见的内容，是设计<em>Java</em>程序必不可少的部分。</p>
<p>过关条件：理解什么是变量，为什么需要使用变量，以及如何使用它们</p>
<p>关卡难度：⭐️</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>什么是变量？为什么要有变量？怎么使用它？</p>
<p>如果你不能很好的回答这三个问题，那么就带着这些疑问来完成本次挑战吧，相信你必能有所收获。</p>
<h3 id="什么是变量"><a href="#什么是变量" class="headerlink" title="什么是变量"></a>什么是变量</h3><p>在一个<em>Java</em>程序中，通常需要很多个步骤才能实现我们想要的功能，比如之前设计的计算器，就需要先提示用户输入，读取输入的值，然后再将它们相加后输出。我们日常生活中的事情也是类似的，拿吃饭而言，我们需要先把饭盛到碗里，然后再加点菜，再往嘴里塞。</p>
<p>这里的碗就相当于变量，我们用它来盛饭，也就是存放中间过程的一些处理结果，饭是我们从锅里盛出来的，是经过我们处理过的。</p>
<p>也许这样说还是有些抽象，我们继续看之前的栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;请输入一个整数:&quot;</span>);</span><br><span class="line">    Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> a = in.nextInt();</span><br><span class="line">    System.out.print(<span class="string">&quot;请再输入一个整数:&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> b = in.nextInt();</span><br><span class="line">    <span class="keyword">int</span> sum = a + b;</span><br><span class="line">    System.out.print(<span class="string">&quot;这两个数的和为:&quot;</span> + sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第三行，我们定义了一个变量<em>in</em>，用来存放<em>Scanner</em>实例引用，在第四行，我们定义了一个变量<em>a</em>，用来存放用户输入的第一个整数，第六行里我们又定义了一个变量<em>b</em>，用来接收用户输入的第二个整数，然后在第七行定义了一个变量<em>sum</em>，用来存放变量<em>a</em>和变量<em>b</em>的和。</p>
<p>虽然是一个简单的程序，但是我们已经使用了四个变量，可见其应用的广泛性和重要性。变量就如同程序的血液，是一个程序能顺利运转的不可或缺的部分。</p>
<h3 id="为什么需要变量"><a href="#为什么需要变量" class="headerlink" title="为什么需要变量"></a>为什么需要变量</h3><p>那么有没有可能不使用任何变量呢？其实也是可以的，比如这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;我是一个最简单的程序，我不使用变量&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但毕竟这样的需求只是极少的一部分，绝大部分的应用还是比较繁杂的，所以变量便不可避免的需要使用。</p>
<p>另外，使用变量还可以使得程序逻辑变得更加清晰，通过使用变量，将整个流程的步骤变得更加清晰明确。就好比说吃饭，不再是模糊的一个概念，而是分为盛饭，夹菜，吃饭这几个具体的步骤了。</p>
<h3 id="如何使用变量"><a href="#如何使用变量" class="headerlink" title="如何使用变量"></a>如何使用变量</h3><p>要想使用变量，就必须先定义一个变量，或者说声明一个变量。声明变量的格式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[类名] + [变量名]</span><br></pre></td></tr></table></figure>
<p>例如：<code>int a</code> 中 <code>int</code> 是变量的类型，<code>a</code> 是变量的名字。</p>
<p>可以在声明变量的同时给它赋一个初始值，也可以在之后改变变量的值。声明变量之后，必须使用赋值语句对变量显式初始化，千万不要使用未初始化的变量，否则会被编译器视为错误的代码。</p>
<p>想要对一个变量进行赋值，就需要将变量放在<code>=</code> 左边，然后将<em>Java</em>表达式放在等号的右边。</p>
<p>举个小栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;变量a的值为：&quot;</span> + a);</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;变量a的值为：&quot;</span> + a);</span><br><span class="line">    a = <span class="number">3</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;变量a的值为：&quot;</span> + a);</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    System.out.println(<span class="string">&quot;变量b的值为：&quot;</span> + b);</span><br><span class="line">    b = a;</span><br><span class="line">    System.out.println(<span class="string">&quot;变量b的值为：&quot;</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么程序将会输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">变量a的值为：<span class="number">1</span></span><br><span class="line">变量a的值为：<span class="number">2</span></span><br><span class="line">变量a的值为：<span class="number">3</span></span><br><span class="line">变量b的值为：<span class="number">0</span></span><br><span class="line">变量b的值为：<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>补充说明一下，<code>System.out.println</code> 与 <code>System.out.print</code> 的区别是，前者会在内容输出完成之后添加一个换行。</p>
<h3 id="变量的命名规范"><a href="#变量的命名规范" class="headerlink" title="变量的命名规范"></a>变量的命名规范</h3><p>变量名必须以字母开头，并且由字母、数字或者下划线和$构成，对于长度理论上来说是没有限制的，此外，<em>Java</em>中的保留字是不能用作变量名的，保留字也就是<em>Java</em>中的关键字，比如之前的 <code>public</code>、<code>static</code>、<code>int</code>、<code>void</code>等等，在后续的学习中，会不断接触到各种关键字。</p>
<p>变量命名最好符合它使用的意义，能表现其作用，因为往往在一个程序中会出现非常多的变量，如果变量命名都像<code>a1</code>、<code>a2</code>、<code>a3</code>这样看了让人摸不着头脑的形式，那么将使得代码的阅读和维护变得十分困难。永远不要忘记，代码是用来阅读的。</p>
<p>在<em>Java</em>中，变量的命名通常使用小驼峰命名法，也就是第一个单词的首字母小写，其余单词的首字母大写，比如：<code>totalDays</code>、<code>paperWidth</code>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，关于变量的介绍就结束了，变量是Java中最重要也是最基础的组成部分，希望你能很好的理解和掌握它。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://good19961106.github.io/2020/05/04/java/basic/java-variable/" data-id="ckjjnjncl0016a8wc3xtz5s64" data-title="【Java基础篇】三、Java 变量" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breeze-blog/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breeze-blog/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-java/basic/java-simple-structure" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/breeze-blog/2020/05/04/java/basic/java-simple-structure/" class="article-date">
  <time class="dt-published" datetime="2020-05-03T15:25:03.000Z" itemprop="datePublished">2020-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/breeze-blog/categories/%E7%BC%96%E7%A8%8B/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/breeze-blog/2020/05/04/java/basic/java-simple-structure/">【Java基础篇】二、Java 程序基本结构</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>“No matter how small and unimportant what we are doing may seem, if we do it well, it may soon become the step that will lead us to better things.”                — Channing Pollock, Writer</p>
<p>「不管我们现在所做的事看起来有么的微不足道或不重要，如果我们认真的做，它可能很快就会成为通往美好事物的踏石阶。」                                – 詹宁‧布鲁克 (作家)</p>
</blockquote>
<h2 id="关卡说明"><a href="#关卡说明" class="headerlink" title="关卡说明"></a>关卡说明</h2><p>关卡描述：<code>Java</code> 程序具有一些固定的形式，本篇将来对此进行简单的说明介绍。</p>
<p>过关条件：理解 <code>Java</code> 程序的基本组成结构</p>
<p>关卡难度：⭐️</p>
<h2 id="一个简单的程序"><a href="#一个简单的程序" class="headerlink" title="一个简单的程序"></a>一个简单的程序</h2><p>为了简单起见，本篇以及之后的很多篇里，都会设计很多“玩具”代码，与实际中 <code>Java</code> 的设计可能相去甚远，本系列中的代示例都是为了说明一些相关概念，让你能够更好的理解 <code>Java</code> 的相关特性。</p>
<p>下面再来看看上一篇中的栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCalculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入一个整数:&quot;</span>);</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> a = in.nextInt();</span><br><span class="line">        System.out.print(<span class="string">&quot;请再输入一个整数:&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> b = in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> sum = a + b;</span><br><span class="line">        System.out.print(<span class="string">&quot;这两个数的和为:&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个非常简单的能够运行的<em>Java</em>程序，它有一些基本的结构，下面将对其一一介绍。</p>
<p>前面两句的作用已经在<a href="../introduction/java-package.md">上一篇</a>中进行说明了，这里就不赘述了。接下来是类的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCalculator</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是定义了一个叫做<em>SimpleCalculator</em>的类，<code>public</code> 称为<em>访问修饰符</em>，用于控制代码的访问级别，关于这部分的内容，会在之后的章节中进行详细的介绍。在这里，<code>public</code> 表示这个类的访问权限为任何外部类均可以访问。<code>class</code> 是定义一个类的关键字，它的后面是类。关于类的命名规范在之后也会有详细说明。不要忘了后面还有一对大括号，表示类的内部内容。</p>
<p>需要注意的是，<strong>Java是区分大小写的</strong>，如果出现了大小写拼写错误，程序是无法正确运行的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在类的内部定义了一个<em>main</em>方法，为什么说它是一个方法而不是类呢？因为它位于一个类的内部，并且没有用<em>class</em>关键字修饰，而且符合方法的定义规范。<code>public</code>同样可以修饰方法，表示这个方法对于外部类是公开的，可以访问的，<code>static</code>表示这是一个静态方法（先不要纠结什么是静态方法），<code>void</code>表示这个方法的返回值类型，<code>main</code>为方法名，后面跟上一对小括号，里面是参数列表，这里为<code>String[] args</code>，表示它接受一个<em>String</em>数组作为参数，<code>args</code>为参数名。</p>
<p>也许上面还有许多概念你还不清楚是什么意思，不要着急，先不要纠结于这些细节，先从整体上把握，继续看下去，后面的文章中会有说明。</p>
<p>需要注意的是，<code>main</code>方法是<em>Java</em>程序中一个十分特殊的方法，它是整个程序的入口，也就是说，程序会从<code>main</code>方法开始执行，因此，如果想要代码能够执行，在类的源文件中必须包含一个<code>main</code>方法。</p>
<p>方法中的方法体则是我们为了实现功能而设计的自定义代码，在<em>Java</em>中，每个句子必须用分号结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(<span class="string">&quot;请输入一个整数:&quot;</span>);</span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> a = in.nextInt();</span><br><span class="line">System.out.print(<span class="string">&quot;请再输入一个整数:&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> b = in.nextInt();</span><br><span class="line"><span class="keyword">int</span> sum = a + b;</span><br><span class="line">System.out.print(<span class="string">&quot;这两个数的和为:&quot;</span> + sum);</span><br></pre></td></tr></table></figure>
<p><em>Java</em>中，点号是用来调用方法或者使用对象的，如：<code>System.out.print(...)</code>表示使用<code>System.out</code>对象并调用它的<code>print</code>方法。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>至此，本篇的<em>Java</em>的基本结构就介绍完毕了，希望通过本篇，你能知道一个简单<em>Java</em>程序的结构是怎样的以及<em>main</em>方法有什么作用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://good19961106.github.io/2020/05/04/java/basic/java-simple-structure/" data-id="ckjjnjncj0011a8wc79zjagyv" data-title="【Java基础篇】二、Java 程序基本结构" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breeze-blog/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breeze-blog/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-java/basic/java-package" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/breeze-blog/2020/05/04/java/basic/java-package/" class="article-date">
  <time class="dt-published" datetime="2020-05-03T15:25:02.000Z" itemprop="datePublished">2020-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/breeze-blog/categories/%E7%BC%96%E7%A8%8B/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/breeze-blog/2020/05/04/java/basic/java-package/">【Java基础篇】一、Java package与import</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>共道人间惆怅事，不知今夕是何年。  – 《周秦行纪》</p>
</blockquote>
<h2 id="关卡说明"><a href="#关卡说明" class="headerlink" title="关卡说明"></a>关卡说明</h2><p>关卡描述：不知你是否还记得上一篇中的代码，前面的两行，这是在 <code>Java</code> 中特定的格式，想要知道它们是什么含义吗？通过本关你就能获得答案。</p>
<p>过关条件：理解 <code>Java</code> 中 <code>package</code> 与 <code>import</code> 的作用以及如何使用它们</p>
<p>关卡难度：⭐️</p>
<h2 id="什么是-package"><a href="#什么是-package" class="headerlink" title="什么是 package"></a>什么是 package</h2><p>现在再来回顾一下我们上一篇中的代码，首先我们创建了一个类，叫做 <code>SimpleCalculator</code> ，文件名叫做 <code>SimpleCalculator.java</code>。</p>
<p>在最开头有这么一行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br></pre></td></tr></table></figure>
<p>第一行会声明这个类所在的包名，因为这个类文件是在 <code>hello</code> 包下的，所以第一行的含义就是表明这个类的位置。</p>
<h2 id="为什么要使用package"><a href="#为什么要使用package" class="headerlink" title="为什么要使用package"></a>为什么要使用package</h2><p>聪明的你也许会想到，同一个包下面应该不允许存在两个相同的文件名，也就是不允许存在相同的类名。确实如此，这也是 <code>package</code> 的一个很重要的作用，为类提供一个类似命名空间的管理，避免同名的类产生冲突。</p>
<p>试想一下，如果没有 <code>package</code> ，所有类都在同一个地方，那就要争先恐后的使用类名了，后来者可能就要为取名想破脑袋，就像注册游戏名时经常感慨好名字都被🐷拱了那样。</p>
<p><code>package</code> 的另一个作用便是用来将 <code>Java</code> 文件进行分类管理，比如有同一种用处的类放到同一个包下，方便查找和管理。</p>
<h2 id="package命名规范"><a href="#package命名规范" class="headerlink" title="package命名规范"></a>package命名规范</h2><p>虽然理论上来说，你可以随心所欲、为所欲为的命名你项目中的包，但还是建议你遵循一定的规范，因为如果大家都遵循规范来设计的话，会减少很多交流成本。</p>
<p><code>package</code> 的命名一般分为几个部分，<code>身份标识.开发者名/团队名/公司名.项目名.模块名</code>，对于身份标识，主要是用来标识是个人开发还是团队开发，个人开发主要使用的标识有：<em>indi</em>（个体项目）、<em>onem</em>（单人项目）、<em>pers</em>（个人项目）、<em>priv</em>（私有项目），团队开发主要使用的标识有：<em>team</em>（团队项目）、<em>com</em>（公司项目）。</p>
<p>但其实没有特殊要求的话，使用域名倒写是最常见的，因为域名是不会重复的。</p>
<p>所以比较常见的命名类似于：<em>com.frank.hello.controller</em>，<em>frank</em>是我的英文名，（假装）<em>frank.com</em>是我的域名，<em>hello</em> 是项目名，<em>controller</em> 则代表这个包都用途，表明在下面我会放控制器（先不用纠结控制器是什么）。</p>
<p>所以，如果还没有英文名的话，赶紧给自己找一个吧。你也许会问，如果有人用了跟自己一样的英文名怎么办？</p>
<p>没有关系，反正极大概率上来说，你又不会使用他的包，即使真遇上了，还是有解决办法的，改改项目名，改改包名，就ok了。</p>
<h2 id="使用package的注意事项"><a href="#使用package的注意事项" class="headerlink" title="使用package的注意事项"></a>使用package的注意事项</h2><ol>
<li><code>package</code> 必须是程序中可执行的第一行代码</li>
<li><code>package</code> 语句只能有一句，且语句后面有分号</li>
<li><code>package</code> 命名要求包含的所有字符均为小写，同时不能有特殊字符</li>
<li><code>package</code> 可以有多层，每一层有<code>.</code>隔开，例如：<code>package com.frank.hello;</code>（com是一个文件夹，<em>frank</em> 是 <em>com</em> 下的一个文件夹，<em>hello</em> 是 <em>frank</em> 文件夹下的一个文件夹）</li>
<li>包的路径符合所开发的系统模块的定义</li>
<li>如果定义类的时候没有使用 <em>package</em>，那么 <em>java</em> 就认为我们所定义的类位于默认包里面(java.lang)。</li>
</ol>
<h2 id="import的作用"><a href="#import的作用" class="headerlink" title="import的作用"></a>import的作用</h2><p>在之前的 <code>SimpleCalculator</code> 类中，我们还看到了这么一句代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br></pre></td></tr></table></figure>
<p>那么 <code>import</code> 又是做什么用的呢？</p>
<p><code>import</code> 是在 <em>java</em> 文件开头的地方，先说明会用到那些类所在的全路径名，这样我们就能在代码中使用对应的类名，而不是使用全路径。</p>
<p>开发中需要引用到其他包下的类，比如 <em>JDK</em> 中一些常用的类，那么就需要先使用 <em>import</em> 告诉编译器我们要引用的类的位置，比如说这里的 <em>Scanner</em> 。那么你也许会注意到，代码中不是有 <code>System</code> 吗，是怎么回事呢？为什么不用引入 <code>System</code> 所在的包呢？</p>
<p>这是一个很好的问题。原因是 <em>java.lang</em> 这个包实在是太常用了，所以默认可以不用写，编译器会自动引入，编译器只要看到没有使用 <code>import</code> 引入包名的类，就会去 <em>java.lang</em> 中找。</p>
<p>那如果要引入一个包下所有类该怎么办呢？</p>
<p>有时候需要用到的类刚好有有多在同一个包下面，一个一个引入，显然太费事，别着急，还有更好的解决办法，可以使用<code>*</code>来匹配所有，比如说：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br></pre></td></tr></table></figure>
<p>那么就会引入<code>java.util</code>包下的所有类。</p>
<p>也许你会觉得，那都使用<code>*</code>的方式不就好了。如果这样想，那就大错特错了，包的存在就是为了减少类名冲突，这样每次都使用<code>*</code>将大量类引入的话，会更容易产生类名冲突，那就适得其反了。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本篇讲解了 <code>package</code> 和 <code>import</code> 的用途，希望通过本篇，你能知道代码中前面的那些代码有什么作用，也能在之后的代码编写中知道如何去正确使用它们。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://good19961106.github.io/2020/05/04/java/basic/java-package/" data-id="ckjjnjnci000ya8wc21374rk4" data-title="【Java基础篇】一、Java package与import" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breeze-blog/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breeze-blog/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-java/basic/java-basic" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/breeze-blog/2020/05/04/java/basic/java-basic/" class="article-date">
  <time class="dt-published" datetime="2020-05-03T15:25:01.000Z" itemprop="datePublished">2020-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/breeze-blog/categories/%E7%BC%96%E7%A8%8B/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/breeze-blog/2020/05/04/java/basic/java-basic/">【Java基础篇】启航</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>无论最终的结果是什么，只要这是自己选择的道路。 – 《龙与虎》</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>Java开发入门篇</strong>十分简单，相信聪明的你已经完成了新手村的任务，顺利打败了小Boss，开启这一新的篇章。​</p>
<p>本篇是<strong>Java基础篇</strong>，主要内容是介绍 <code>Java</code> 开发中的<em>基础概念</em>和<em>基本知识</em>，包括 <code>Java</code> 程序的基本组成，<code>Java</code> 中的<code>类</code>与<code>对象</code>、<code>数据类型</code>、<code>变量</code>与<code>常量</code>、<code>运算符</code>、<code>控制流程</code>、<code>接口</code>、<code>封装</code>、<code>继承</code>与<code>多态</code>等等。这些基本要素是组成 <code>Java</code> 程序必不可少的部分，要想对 <code>Java</code> 有一个全面的认识，那么就必须认真掌握好这些基本知识。</p>
<p>就像学习高深莫测的武林秘籍之前必须要先学会一些基本的内功心法和基础招式那样，本篇的重要性不言自明，只有打好基础，才能在更高深的技能上有所突破。</p>
<p>为了不让这个过程太过枯燥，本篇将继续完善上一篇中的计算器，以它为基础进行分析，并随着学习的深入，让它的功能变得越来越强大。当然，除了这个计算器之外，还会有很多小栗子伴随其中，以加深大家对这个部分的理解。</p>
<p>之后的每一篇开头，都会引用一句话来作为鼓励，希望它能成为激励你继续前进的精神力量。</p>
<p>那么，年轻的勇士，继续你的征程吧！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://good19961106.github.io/2020/05/04/java/basic/java-basic/" data-id="ckjjnjncf000sa8wc80ko00fp" data-title="【Java基础篇】启航" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breeze-blog/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breeze-blog/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/breeze-blog/">&laquo; Prev</a><a class="page-number" href="/breeze-blog/">1</a><span class="page-number current">2</span><a class="page-number" href="/breeze-blog/page/3/">3</a><a class="extend next" rel="next" href="/breeze-blog/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/breeze-blog/categories/%E7%BC%96%E7%A8%8B/">编程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/breeze-blog/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a></li><li class="category-list-item"><a class="category-list-link" href="/breeze-blog/categories/%E7%BC%96%E7%A8%8B/%E7%94%9F%E6%B4%BB/">生活</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/DelayQueue/" rel="tag">DelayQueue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/Java%E5%85%A5%E9%97%A8/" rel="tag">Java入门</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/R/" rel="tag">R</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/RabbitMQ/" rel="tag">RabbitMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/Thoughts/" rel="tag">Thoughts</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/github-pages/" rel="tag">github pages</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/go/" rel="tag">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/travis-ci/" rel="tag">travis ci</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/%E4%BC%98%E9%9B%85%E9%87%8D%E8%AF%95/" rel="tag">优雅重试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" rel="tag">最佳实践</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">环境搭建</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/breeze-blog/tags/DelayQueue/" style="font-size: 10px;">DelayQueue</a> <a href="/breeze-blog/tags/Hexo/" style="font-size: 12.86px;">Hexo</a> <a href="/breeze-blog/tags/Java/" style="font-size: 20px;">Java</a> <a href="/breeze-blog/tags/Java%E5%85%A5%E9%97%A8/" style="font-size: 18.57px;">Java入门</a> <a href="/breeze-blog/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 15.71px;">Java基础</a> <a href="/breeze-blog/tags/R/" style="font-size: 11.43px;">R</a> <a href="/breeze-blog/tags/RabbitMQ/" style="font-size: 14.29px;">RabbitMQ</a> <a href="/breeze-blog/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/breeze-blog/tags/Thoughts/" style="font-size: 11.43px;">Thoughts</a> <a href="/breeze-blog/tags/github-pages/" style="font-size: 10px;">github pages</a> <a href="/breeze-blog/tags/go/" style="font-size: 12.86px;">go</a> <a href="/breeze-blog/tags/travis-ci/" style="font-size: 10px;">travis ci</a> <a href="/breeze-blog/tags/%E4%BC%98%E9%9B%85%E9%87%8D%E8%AF%95/" style="font-size: 10px;">优雅重试</a> <a href="/breeze-blog/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" style="font-size: 10px;">最佳实践</a> <a href="/breeze-blog/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" style="font-size: 17.14px;">环境搭建</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/breeze-blog/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/breeze-blog/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/breeze-blog/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/breeze-blog/archives/2020/05/">May 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/breeze-blog/2021/01/05/picture/go-draw-word-in-pic2/">(no title)</a>
          </li>
        
          <li>
            <a href="/breeze-blog/2021/01/05/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/breeze-blog/2020/12/20/picture/go-draw-word-in-pic/">【Go语言绘图】图片添加文字（一）</a>
          </li>
        
          <li>
            <a href="/breeze-blog/2020/12/16/picture/go-pic-rotate-use-gg-package/">【Go语言绘图】图片的旋转</a>
          </li>
        
          <li>
            <a href="/breeze-blog/2020/11/29/picture/go-basic-usage-of-gg-package/">【Go语言绘图】gg 库的基本使用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/breeze-blog/" class="mobile-nav-link">Home</a>
  
    <a href="/breeze-blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/breeze-blog/js/jquery-3.4.1.min.js"></script>



  
<script src="/breeze-blog/fancybox/jquery.fancybox.min.js"></script>




<script src="/breeze-blog/js/script.js"></script>





  </div>
</body>
</html>