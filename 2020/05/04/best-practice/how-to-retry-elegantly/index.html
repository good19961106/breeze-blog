<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>【最佳实践】如何优雅的进行重试 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="本文口味：冰镇杨梅           预计阅读：20分钟 说明最近公司在搞活动，需要依赖一个第三方接口，测试阶段并没有什么异常状况，但上线后发现依赖的接口有时候会因为内部错误而返回系统异常，虽然概率不大，但总因为这个而报警总是不好的，何况死信队列的消息还需要麻烦运维进行重新投递，所以加上重试机制势在必行。 重试机制可以保护系统减少因网络波动、依赖服务短暂性不可用带来的影响，让系统能更稳定的运行的">
<meta property="og:type" content="article">
<meta property="og:title" content="【最佳实践】如何优雅的进行重试">
<meta property="og:url" content="https://good19961106.github.io/2020/05/04/best-practice/how-to-retry-elegantly/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="本文口味：冰镇杨梅           预计阅读：20分钟 说明最近公司在搞活动，需要依赖一个第三方接口，测试阶段并没有什么异常状况，但上线后发现依赖的接口有时候会因为内部错误而返回系统异常，虽然概率不大，但总因为这个而报警总是不好的，何况死信队列的消息还需要麻烦运维进行重新投递，所以加上重试机制势在必行。 重试机制可以保护系统减少因网络波动、依赖服务短暂性不可用带来的影响，让系统能更稳定的运行的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2019/08/04/eAUjdRTgskmWF3f.png">
<meta property="og:image" content="https://i.loli.net/2019/08/04/ABwDil3xTFaIfyu.png">
<meta property="og:image" content="https://i.loli.net/2019/08/04/z6JxEGdhUK9y1YW.png">
<meta property="og:image" content="https://i.loli.net/2019/08/11/w8R6EAGCtkneQhI.jpg">
<meta property="og:image" content="https://i.loli.net/2019/08/11/GzmFVto59SLMgOl.jpg">
<meta property="og:image" content="https://i.loli.net/2019/08/11/IczsWOdt4PL6vom.jpg">
<meta property="og:image" content="https://i.loli.net/2019/08/11/fOegoZhjwECGbA9.jpg">
<meta property="og:image" content="https://i.loli.net/2019/08/11/9CuPZHtqMbpLA8a.jpg">
<meta property="og:image" content="https://i.loli.net/2019/08/11/MFpbWwysvP6Zqo7.jpg">
<meta property="og:image" content="https://i.loli.net/2019/08/11/8MxBPNgyIlTZDRk.png">
<meta property="article:published_time" content="2020-05-03T16:00:10.000Z">
<meta property="article:modified_time" content="2020-12-22T12:17:37.000Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="最佳实践">
<meta property="article:tag" content="优雅重试">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2019/08/04/eAUjdRTgskmWF3f.png">
  
    <link rel="alternate" href="/breeze-blog/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/breeze-blog/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/breeze-blog/css/style.css">

  
    
<link rel="stylesheet" href="/breeze-blog/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/breeze-blog/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/breeze-blog/">Home</a>
        
          <a class="main-nav-link" href="/breeze-blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/breeze-blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://good19961106.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-best-practice/how-to-retry-elegantly" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/breeze-blog/2020/05/04/best-practice/how-to-retry-elegantly/" class="article-date">
  <time class="dt-published" datetime="2020-05-03T16:00:10.000Z" itemprop="datePublished">2020-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/breeze-blog/categories/%E7%BC%96%E7%A8%8B/">编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      【最佳实践】如何优雅的进行重试
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文口味：冰镇杨梅           预计阅读：20分钟</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>最近公司在搞活动，需要依赖一个第三方接口，测试阶段并没有什么异常状况，但上线后发现依赖的接口有时候会因为内部错误而返回系统异常，虽然概率不大，但总因为这个而报警总是不好的，何况死信队列的消息还需要麻烦运维进行重新投递，所以加上重试机制势在必行。</p>
<p>重试机制可以保护系统减少因网络波动、依赖服务短暂性不可用带来的影响，让系统能更稳定的运行的一种保护机制。让你原本就稳如狗的系统更是稳上加稳。</p>
<p><img src="https://i.loli.net/2019/08/04/eAUjdRTgskmWF3f.png" alt="1"></p>
<p>为了方便说明，先假设我们想要进行重试的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicLong helloTimes = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> times = helloTimes.incrementAndGet();</span><br><span class="line">        <span class="keyword">if</span> (times % <span class="number">4</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            log.warn(<span class="string">&quot;发生异常，time：&#123;&#125;&quot;</span>, LocalTime.now() );</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HelloRetryException(<span class="string">&quot;发生Hello异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用处：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloRetryService</span> <span class="keyword">implements</span> <span class="title">IHelloService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloService.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，这个接口每调4次才会成功一次。</p>
<h2 id="手动重试"><a href="#手动重试" class="headerlink" title="手动重试"></a>手动重试</h2><p>先来用最简单的方法，直接在调用的时候进重试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动重试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxRetryTimes = <span class="number">4</span>;</span><br><span class="line">    String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> retry = <span class="number">1</span>; retry &lt;= maxRetryTimes; retry++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s = helloService.hello();</span><br><span class="line">            log.info(<span class="string">&quot;helloService返回:&#123;&#125;&quot;</span>, s);</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (HelloRetryException e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;helloService.hello() 调用失败，准备重试&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HelloRetryException(<span class="string">&quot;重试次数耗尽&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">发生异常，time：10:17:21.079413300</span><br><span class="line">helloService.hello() 调用失败，准备重试</span><br><span class="line">发生异常，time：10:17:21.085861800</span><br><span class="line">helloService.hello() 调用失败，准备重试</span><br><span class="line">发生异常，time：10:17:21.085861800</span><br><span class="line">helloService.hello() 调用失败，准备重试</span><br><span class="line">helloService返回:hello</span><br><span class="line">service.helloRetry()：hello</span><br></pre></td></tr></table></figure>
<p>程序在极短的时间内进行了4次重试，然后成功返回。</p>
<p>这样虽然看起来可以解决问题，但实践上，由于没有重试间隔，很可能当时依赖的服务尚未从网络异常中恢复过来，所以极有可能接下来的几次调用都是失败的。</p>
<p>而且，这样需要对代码进行大量的侵入式修改，显然，不优雅。</p>
<p><img src="https://i.loli.net/2019/08/04/ABwDil3xTFaIfyu.png" alt="3.png"></p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>上面的处理方式由于需要对业务代码进行大量修改，虽然实现了功能，但是对原有代码的侵入性太强，可维护性差。</p>
<p>所以需要使用一种更优雅一点的方式，不直接修改业务代码，那要怎么做呢？</p>
<p>其实很简单，直接在业务代码的外面再包一层就行了，代理模式在这里就有用武之地了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloRetryProxyService</span> <span class="keyword">implements</span> <span class="title">IHelloService</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloRetryService helloRetryService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxRetryTimes = <span class="number">4</span>;</span><br><span class="line">        String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> retry = <span class="number">1</span>; retry &lt;= maxRetryTimes; retry++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                s = helloRetryService.hello();</span><br><span class="line">                log.info(<span class="string">&quot;helloRetryService 返回:&#123;&#125;&quot;</span>, s);</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (HelloRetryException e) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;helloRetryService.hello() 调用失败，准备重试&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HelloRetryException(<span class="string">&quot;重试次数耗尽&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，重试逻辑就都由代理类来完成，原业务类的逻辑就不需要修改了，以后想修改重试逻辑也只需要修改这个类就行了，分工明确。比如，现在想要在重试之间加上一个延迟，只需要做一点点修改即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxRetryTimes = <span class="number">4</span>;</span><br><span class="line">    String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> retry = <span class="number">1</span>; retry &lt;= maxRetryTimes; retry++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            s = helloRetryService.hello();</span><br><span class="line">            log.info(<span class="string">&quot;helloRetryService 返回:&#123;&#125;&quot;</span>, s);</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (HelloRetryException e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;helloRetryService.hello() 调用失败，准备重试&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 延时一秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HelloRetryException(<span class="string">&quot;重试次数耗尽&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理模式虽然要更加优雅，但是如果依赖的服务很多的时候，要为每个服务都创建一个代理类，显然过于麻烦，而且其实重试的逻辑都大同小异，无非就是重试的次数和延时不一样而已。如果每个类都写这么一长串类似的代码，显然，不优雅！</p>
<p><img src="https://i.loli.net/2019/08/04/z6JxEGdhUK9y1YW.png" alt="4.png"></p>
<h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>这时候，动态代理就闪亮登场了。只需要写一个代理处理类，就可以开局一条狗，砍到九十九。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RetryInvocationHandler</span><span class="params">(Object subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (times &lt; RetryConstant.MAX_TIMES) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(subject, args);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                times++;</span><br><span class="line">                log.info(<span class="string">&quot;times:&#123;&#125;,time:&#123;&#125;&quot;</span>, times, LocalTime.now());</span><br><span class="line">                <span class="keyword">if</span> (times &gt;= RetryConstant.MAX_TIMES) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 延时一秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取动态代理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> realSubject 代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Object realSubject)</span> </span>&#123;</span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> RetryInvocationHandler(realSubject);</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(handler.getClass().getClassLoader(),</span><br><span class="line">                realSubject.getClass().getInterfaces(), handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来一发单元测：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloDynamicProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IHelloService realService = <span class="keyword">new</span> HelloService();</span><br><span class="line">    IHelloService proxyService = (IHelloService)RetryInvocationHandler.getProxy(realService);</span><br><span class="line"></span><br><span class="line">    String hello = proxyService.hello();</span><br><span class="line">    log.info(<span class="string">&quot;hello:&#123;&#125;&quot;</span>, hello);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hello times:1</span><br><span class="line">发生异常，time：11:22:20.727586700</span><br><span class="line">times:1,time:11:22:20.728083</span><br><span class="line">hello times:2</span><br><span class="line">发生异常，time：11:22:21.728858700</span><br><span class="line">times:2,time:11:22:21.729343700</span><br><span class="line">hello times:3</span><br><span class="line">发生异常，time：11:22:22.729706600</span><br><span class="line">times:3,time:11:22:22.729706600</span><br><span class="line">hello times:4</span><br><span class="line">hello:hello</span><br></pre></td></tr></table></figure>
<p>在重试了4次之后输出了<code>Hello</code>，符合预期。</p>
<p>动态代理可以将重试逻辑都放到一块，显然比直接使用代理类要方便很多，也更加优雅。</p>
<p>不过不要高兴的太早，这里因为被代理的<em>HelloService</em>是一个简单的类，没有依赖其它类，所以直接创建是没有问题的，但如果被代理的类依赖了其它被<em>Spring</em>容器管理的类，则这种方式会抛出异常，因为没有把被依赖的实例注入到创建的代理实例中。</p>
<p>这种情况下，就比较复杂了，需要从<em>Spring</em>容器中获取已经装配好的，需要被代理的实例，然后为其创建代理类实例，并交给<em>Spring</em>容器来管理，这样就不用每次都重新创建新的代理类实例了。</p>
<p>话不多说，撸起袖子就是干。</p>
<p><img src="https://i.loli.net/2019/08/11/w8R6EAGCtkneQhI.jpg" alt="timg.jpg"></p>
<p>新建一个工具类，用来获取代理实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryProxyHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ConfigurableApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 从Bean中获取对象</span></span><br><span class="line">        DefaultListableBeanFactory beanFactory = (DefaultListableBeanFactory)context.getAutowireCapableBeanFactory();</span><br><span class="line">        Map&lt;String, Object&gt; beans = beanFactory.getBeansOfType(clazz);</span><br><span class="line">        Set&lt;Map.Entry&lt;String, Object&gt;&gt; entries = beans.entrySet();</span><br><span class="line">        <span class="keyword">if</span> (entries.size() &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ProxyBeanNotFoundException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有多个候选bean, 判断其中是否有代理bean</span></span><br><span class="line">        Object bean = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (entries.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : entries) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry.getKey().contains(PROXY_BEAN_SUFFIX))&#123;</span><br><span class="line">                    bean = entry.getValue();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">if</span> (bean != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> bean;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ProxyBeanNotSingleException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object source = beans.entrySet().iterator().next().getValue();</span><br><span class="line">        Object source = beans.entrySet().iterator().next().getValue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 判断该对象的代理对象是否存在</span></span><br><span class="line">        String proxyBeanName = clazz.getSimpleName() + PROXY_BEAN_SUFFIX;</span><br><span class="line">        Boolean exist = beanFactory.containsBean(proxyBeanName);</span><br><span class="line">        <span class="keyword">if</span> (exist) &#123;</span><br><span class="line">            bean = beanFactory.getBean(proxyBeanName);</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 不存在则生成代理对象</span></span><br><span class="line">        bean = RetryInvocationHandler.getProxy(source);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 将bean注入spring容器</span></span><br><span class="line">        beanFactory.registerSingleton(proxyBeanName, bean);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的是<code>JDK动态代理</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RetryInvocationHandler</span><span class="params">(Object subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (times &lt; RetryConstant.MAX_TIMES) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(subject, args);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                times++;</span><br><span class="line">                log.info(<span class="string">&quot;retry times:&#123;&#125;,time:&#123;&#125;&quot;</span>, times, LocalTime.now());</span><br><span class="line">                <span class="keyword">if</span> (times &gt;= RetryConstant.MAX_TIMES) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 延时一秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取动态代理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> realSubject 代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Object realSubject)</span> </span>&#123;</span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> RetryInvocationHandler(realSubject);</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(handler.getClass().getClassLoader(),</span><br><span class="line">                realSubject.getClass().getInterfaces(), handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，主要代码就完成了，修改一下<em>HelloService</em>类，增加一个依赖：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> <span class="keyword">implements</span> <span class="title">IHelloService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicLong helloTimes = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> NameService nameService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> times = helloTimes.incrementAndGet();</span><br><span class="line">        log.info(<span class="string">&quot;hello times:&#123;&#125;&quot;</span>, times);</span><br><span class="line">        <span class="keyword">if</span> (times % <span class="number">4</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            log.warn(<span class="string">&quot;发生异常，time：&#123;&#125;&quot;</span>, LocalTime.now() );</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HelloRetryException(<span class="string">&quot;发生Hello异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + nameService.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>NameService</em>其实很简单，创建的目的仅在于测试依赖注入的<em>Bean</em>能否正常运行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Frank&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来一发测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloJdkProxy</span><span class="params">()</span> <span class="keyword">throws</span> InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">    IHelloService proxy = (IHelloService) retryProxyHandler.getProxy(HelloService.class);</span><br><span class="line">    String hello = proxy.hello();</span><br><span class="line">    log.info(<span class="string">&quot;hello:&#123;&#125;&quot;</span>, hello);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hello times:1</span><br><span class="line">发生异常，time：14:40:27.540672200</span><br><span class="line">retry times:1,time:14:40:27.541167400</span><br><span class="line">hello times:2</span><br><span class="line">发生异常，time：14:40:28.541584600</span><br><span class="line">retry times:2,time:14:40:28.542033500</span><br><span class="line">hello times:3</span><br><span class="line">发生异常，time：14:40:29.542161500</span><br><span class="line">retry times:3,time:14:40:29.542161500</span><br><span class="line">hello times:4</span><br><span class="line">hello:hello Frank</span><br></pre></td></tr></table></figure>
<p>完美，这样就不用担心依赖注入的问题了，因为从<em>Spring</em>容器中拿到的<em>Bean</em>对象都是已经注入配置好的。当然，这里仅考虑了单例<em>Bean</em>的情况，可以考虑的更加完善一点，判断一下容器中<em>Bean</em>的类型是Singleton还是<em>Prototype</em>，如果是<em>Singleton</em>则像上面这样进行操作，如果是<em>Prototype</em>则每次都新建代理类对象。</p>
<p>另外，这里使用的是<code>JDK动态代理</code>，因此就存在一个天然的缺陷，如果想要被代理的类，没有实现任何接口，那么就无法为其创建代理对象，这种方式就行不通了。</p>
<p><img src="https://i.loli.net/2019/08/11/GzmFVto59SLMgOl.jpg" alt="EDaBTlbkyvbhmng.jpg"></p>
<h2 id="CGLib-动态代理"><a href="#CGLib-动态代理" class="headerlink" title="CGLib 动态代理"></a>CGLib 动态代理</h2><p>既然已经说到了<code>JDK动态代理</code>，那就不得不提<code>CGLib动态代理</code>了。使用<code>JDK动态代理</code>对被代理的类有要求，不是所有的类都能被代理，而<code>CGLib动态代理</code>则刚好解决了这个问题。</p>
<p>创建一个<code>CGLib动态代理</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibRetryProxyHandler</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;<span class="comment">//需要代理的目标对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写拦截方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] arr, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (times &lt; RetryConstant.MAX_TIMES) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(target, arr);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                times++;</span><br><span class="line">                log.info(<span class="string">&quot;cglib retry :&#123;&#125;,time:&#123;&#125;&quot;</span>, times, LocalTime.now());</span><br><span class="line">                <span class="keyword">if</span> (times &gt;= RetryConstant.MAX_TIMES) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 延时一秒</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义获取代理对象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getCglibProxy</span><span class="params">(Object objectTarget)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = objectTarget;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(objectTarget.getClass());</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        Object result = enhancer.create();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想要换用<code>CGLib动态代理</code>，替换一下这两行代码即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 不存在则生成代理对象</span></span><br><span class="line"><span class="comment">//        bean = RetryInvocationHandler.getProxy(source);</span></span><br><span class="line">CGLibRetryProxyHandler proxyHandler = <span class="keyword">new</span> CGLibRetryProxyHandler();</span><br><span class="line">bean = proxyHandler.getCglibProxy(source);</span><br></pre></td></tr></table></figure>
<p>开始测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloCGLibProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IHelloService proxy = (IHelloService) retryProxyHandler.getProxy(HelloService.class);</span><br><span class="line">    String hello = proxy.hello();</span><br><span class="line">    log.info(<span class="string">&quot;hello:&#123;&#125;&quot;</span>, hello);</span><br><span class="line"></span><br><span class="line">    hello = proxy.hello();</span><br><span class="line">    log.info(<span class="string">&quot;hello:&#123;&#125;&quot;</span>, hello);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">hello times:1</span><br><span class="line">发生异常，time：15:06:00.799679100</span><br><span class="line">cglib retry :1,time:15:06:00.800175400</span><br><span class="line">hello times:2</span><br><span class="line">发生异常，time：15:06:01.800848600</span><br><span class="line">cglib retry :2,time:15:06:01.801343100</span><br><span class="line">hello times:3</span><br><span class="line">发生异常，time：15:06:02.802180</span><br><span class="line">cglib retry :3,time:15:06:02.802180</span><br><span class="line">hello times:4</span><br><span class="line">hello:hello Frank</span><br><span class="line">hello times:5</span><br><span class="line">发生异常，time：15:06:03.803933800</span><br><span class="line">cglib retry :1,time:15:06:03.803933800</span><br><span class="line">hello times:6</span><br><span class="line">发生异常，time：15:06:04.804945400</span><br><span class="line">cglib retry :2,time:15:06:04.805442</span><br><span class="line">hello times:7</span><br><span class="line">发生异常，time：15:06:05.806886500</span><br><span class="line">cglib retry :3,time:15:06:05.807881300</span><br><span class="line">hello times:8</span><br><span class="line">hello:hello Frank</span><br></pre></td></tr></table></figure>
<p>这样就很棒了，完美的解决了<code>JDK动态代理</code>带来的缺陷。优雅指数上涨了不少。</p>
<p>但这个方案仍旧存在一个问题，那就是需要对原来的逻辑进行侵入式修改，在每个被代理实例被调用的地方都需要进行调整，这样仍然会对原有代码带来较多修改。</p>
<p><img src="https://i.loli.net/2019/08/11/IczsWOdt4PL6vom.jpg" alt="fuuTyTbkyvbhmsa.jpg"></p>
<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><p>想要无侵入式的修改原有逻辑？想要一个注解就实现重试？用<code>Spring AOP</code>不就能完美实现吗？使用<code>AOP</code>来为目标调用设置切面，即可在目标方法调用前后添加一些额外的逻辑。</p>
<p>先创建一个注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retryable &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">retryTimes</span><span class="params">()</span> <span class="keyword">default</span> 3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">retryInterval</span><span class="params">()</span> <span class="keyword">default</span> 1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有两个参数，<em>retryTimes</em> 代表最大重试次数，<em>retryInterval</em>代表重试间隔。</p>
<p>然后在需要重试的方法上加上注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retryable(retryTimes = 4, retryInterval = 2)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> times = helloTimes.incrementAndGet();</span><br><span class="line">    log.info(<span class="string">&quot;hello times:&#123;&#125;&quot;</span>, times);</span><br><span class="line">    <span class="keyword">if</span> (times % <span class="number">4</span> != <span class="number">0</span>)&#123;</span><br><span class="line">        log.warn(<span class="string">&quot;发生异常，time：&#123;&#125;&quot;</span>, LocalTime.now() );</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HelloRetryException(<span class="string">&quot;发生Hello异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + nameService.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，进行最后一步，编写<em>AOP</em>切面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.mfrank.springboot.retry.demo.annotation.Retryable)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">retryMethodCall</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;retryMethodCall()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">retry</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取重试次数和重试间隔</span></span><br><span class="line">        Retryable retry = ((MethodSignature)joinPoint.getSignature()).getMethod().getAnnotation(Retryable.class);</span><br><span class="line">        <span class="keyword">int</span> maxRetryTimes = retry.retryTimes();</span><br><span class="line">        <span class="keyword">int</span> retryInterval = retry.retryInterval();</span><br><span class="line"></span><br><span class="line">        Throwable error = <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> retryTimes = <span class="number">1</span>; retryTimes &lt;= maxRetryTimes; retryTimes++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object result = joinPoint.proceed();</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                error = throwable;</span><br><span class="line">                log.warn(<span class="string">&quot;调用发生异常，开始重试，retryTimes:&#123;&#125;&quot;</span>, retryTimes);</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(retryInterval * <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RetryExhaustedException(<span class="string">&quot;重试次数耗尽&quot;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开始测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> HelloService helloService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloAOP</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String hello = helloService.hello();</span><br><span class="line">    log.info(<span class="string">&quot;hello:&#123;&#125;&quot;</span>, hello);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hello times:1</span><br><span class="line">发生异常，time：16:49:30.224649800</span><br><span class="line">调用发生异常，开始重试，retryTimes:1</span><br><span class="line">hello times:2</span><br><span class="line">发生异常，time：16:49:32.225230800</span><br><span class="line">调用发生异常，开始重试，retryTimes:2</span><br><span class="line">hello times:3</span><br><span class="line">发生异常，time：16:49:34.225968900</span><br><span class="line">调用发生异常，开始重试，retryTimes:3</span><br><span class="line">hello times:4</span><br><span class="line">hello:hello Frank</span><br></pre></td></tr></table></figure>
<p>这样就相当优雅了，一个注解就能搞定重试，简直不要更棒。</p>
<p><img src="https://i.loli.net/2019/08/11/fOegoZhjwECGbA9.jpg" alt="IStGDBbkyvbhmow.jpg"></p>
<h2 id="Spring-的重试注解"><a href="#Spring-的重试注解" class="headerlink" title="Spring 的重试注解"></a>Spring 的重试注解</h2><p>实际上<em>Spring</em>中就有比较完善的重试机制，比上面的切面更加好用，还不需要自己动手重新造轮子。</p>
<p>那让我们先来看看这个轮子究竟好不好使。</p>
<p>先引入重试所需的jar包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.retry<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-retry<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在启动类或者配置类上添加*@EnableRetry<em>注解，接下来在需要重试的方法上添加</em>@Retryable*注解（嗯？好像跟我自定义的注解一样？竟然抄袭我的注解！ [手动滑稽] ） </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retryable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> times = helloTimes.incrementAndGet();</span><br><span class="line">    log.info(<span class="string">&quot;hello times:&#123;&#125;&quot;</span>, times);</span><br><span class="line">    <span class="keyword">if</span> (times % <span class="number">4</span> != <span class="number">0</span>)&#123;</span><br><span class="line">        log.warn(<span class="string">&quot;发生异常，time：&#123;&#125;&quot;</span>, LocalTime.now() );</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HelloRetryException(<span class="string">&quot;发生Hello异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + nameService.getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，会重试三次，重试间隔为1秒。当然我们也可以自定义重试次数和间隔。这样就跟我前面实现的功能是一毛一样的了。</p>
<p>但<em>Spring</em>里的重试机制还支持很多很有用的特性，比如说，可以指定只对特定类型的异常进行重试，这样如果抛出的是其它类型的异常则不会进行重试，就可以对重试进行更细粒度的控制。默认为空，会对所有异常都重试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retryable</span>&#123;value = &#123;HelloRetryException.class&#125;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用<em>include</em>和<em>exclude</em>来指定包含或者排除哪些异常进行重试。</p>
<p>可以用<em>maxAttemps</em>指定最大重试次数，默认为3次。</p>
<p>可以用<em>interceptor</em>设置重试拦截器的bean名称。</p>
<p>可以通过<em>label</em>设置该重试的唯一标志，用于统计输出。</p>
<p>可以使用<em>exceptionExpression</em>来添加异常表达式，在抛出异常后执行，以判断后续是否进行重试。</p>
<p>此外，<em>Spring</em>中的重试机制还支持使用<em>backoff</em>来设置重试补偿机制，可以设置重试间隔，并且支持设置重试延迟倍数。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retryable(value = &#123;HelloRetryException.class&#125;, maxAttempts = 5,</span></span><br><span class="line"><span class="meta">           backoff = @Backoff(delay = 1000, multiplier = 2))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法调用将会在抛出<em>HelloRetryException</em>异常后进行重试，最大重试次数为5，第一次重试间隔为1s，之后以2倍大小进行递增，第二次重试间隔为2s，第三次为4s，第四次为8s。</p>
<p>重试机制还支持使用 <code>@Recover</code> 注解来进行善后工作，当重试达到指定次数之后，将会调用该方法，可以在该方法中进行日志记录等操作。</p>
<p>这里值得注意的是，想要 <code>@Recover</code> 注解生效的话，需要跟被 <code>@Retryable</code> 标记的方法在同一个类中，且被 <code>@Retryable</code> 标记的方法不能有返回值，否则不会生效。</p>
<p>并且如果使用了 <code>@Recover</code> 注解的话，重试次数达到最大次数后，如果在 <code>@Recover</code> 标记的方法中无异常抛出，是不会抛出原异常的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Recover</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recover</span><span class="params">(Exception e)</span> </span>&#123;</span><br><span class="line">    log.error(<span class="string">&quot;达到最大重试次数&quot;</span>,e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了使用注解外，<code>Spring Retry</code> 也支持直接在调用时使用代码进行重试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">normalSpringRetry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表示哪些异常需要重试,key表示异常的字节码,value为true表示需要重试</span></span><br><span class="line">    Map&lt;Class&lt;? extends Throwable&gt;, Boolean&gt; exceptionMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    exceptionMap.put(HelloRetryException.class, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建重试模板实例</span></span><br><span class="line">    RetryTemplate retryTemplate = <span class="keyword">new</span> RetryTemplate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置重试回退操作策略，主要设置重试间隔时间</span></span><br><span class="line">    FixedBackOffPolicy backOffPolicy = <span class="keyword">new</span> FixedBackOffPolicy();</span><br><span class="line">    <span class="keyword">long</span> fixedPeriodTime = <span class="number">1000L</span>;</span><br><span class="line">    backOffPolicy.setBackOffPeriod(fixedPeriodTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置重试策略，主要设置重试次数</span></span><br><span class="line">    <span class="keyword">int</span> maxRetryTimes = <span class="number">3</span>;</span><br><span class="line">    SimpleRetryPolicy retryPolicy = <span class="keyword">new</span> SimpleRetryPolicy(maxRetryTimes, exceptionMap);</span><br><span class="line"></span><br><span class="line">    retryTemplate.setRetryPolicy(retryPolicy);</span><br><span class="line">    retryTemplate.setBackOffPolicy(backOffPolicy);</span><br><span class="line"></span><br><span class="line">    Boolean execute = retryTemplate.execute(</span><br><span class="line">        <span class="comment">//RetryCallback</span></span><br><span class="line">        retryContext -&gt; &#123;</span><br><span class="line">            String hello = helloService.hello();</span><br><span class="line">            log.info(<span class="string">&quot;调用的结果:&#123;&#125;&quot;</span>, hello);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// RecoverCallBack</span></span><br><span class="line">        retryContext -&gt; &#123;</span><br><span class="line">            <span class="comment">//RecoveryCallback</span></span><br><span class="line">            log.info(<span class="string">&quot;已达到最大重试次数&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时唯一的好处是可以设置多种重试策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NeverRetryPolicy：只允许调用RetryCallback一次，不允许重试</span><br><span class="line"></span><br><span class="line">AlwaysRetryPolicy：允许无限重试，直到成功，此方式逻辑不当会导致死循环</span><br><span class="line"></span><br><span class="line">SimpleRetryPolicy：固定次数重试策略，默认重试最大次数为<span class="number">3</span>次，RetryTemplate默认使用的策略</span><br><span class="line"></span><br><span class="line">TimeoutRetryPolicy：超时时间重试策略，默认超时时间为<span class="number">1</span>秒，在指定的超时时间内允许重试</span><br><span class="line"></span><br><span class="line">ExceptionClassifierRetryPolicy：设置不同异常的重试策略，类似组合重试策略，区别在于这里只区分不同异常的重试</span><br><span class="line"></span><br><span class="line">CircuitBreakerRetryPolicy：有熔断功能的重试策略，需设置<span class="number">3</span>个参数openTimeout、resetTimeout和delegate</span><br><span class="line"></span><br><span class="line">CompositeRetryPolicy：组合重试策略，有两种组合方式，乐观组合重试策略是指只要有一个策略允许即可以重试，</span><br><span class="line">悲观组合重试策略是指只要有一个策略不允许即可以重试，但不管哪种组合方式，组合中的每一个策略都会执行</span><br></pre></td></tr></table></figure>
<p>可以看出，<code>Spring</code> 中的重试机制还是相当完善的，比上面自己写的 <code>AOP</code> 切面功能更加强大。</p>
<p>这里还需要再提醒的一点是，由于<code>Spring Retry</code>用到了<code>Aspect</code>增强，所以就会有使用<code>Aspect</code>不可避免的坑——方法内部调用，如果被 <code>@Retryable</code> 注解的方法的调用方和被调用方处于同一个类中，那么重试将会失效。</p>
<p>但也还是存在一定的不足，<code>Spring</code>的重试机制只支持对异常进行捕获，而无法对返回值进行校验。</p>
<p><img src="https://i.loli.net/2019/08/11/9CuPZHtqMbpLA8a.jpg" alt="dtFxiMbkyvbhlzo.jpg"></p>
<h2 id="Guava-Retry"><a href="#Guava-Retry" class="headerlink" title="Guava Retry"></a>Guava Retry</h2><p>最后，再介绍另一个重试利器——<code>Guava Retry</code>。</p>
<p>相比<code>Spring Retry</code>，<code>Guava Retry</code>具有更强的灵活性，可以根据返回值校验来判断是否需要进行重试。</p>
<p>先来看一个小栗子：</p>
<p>先引入jar包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.rholder<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava-retrying<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后用一个小Demo来感受一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">guavaRetry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Retryer&lt;String&gt; retryer = RetryerBuilder.&lt;String&gt;newBuilder()</span><br><span class="line">        .retryIfExceptionOfType(HelloRetryException.class)</span><br><span class="line">        .retryIfResult(StringUtils::isEmpty)</span><br><span class="line">        .withWaitStrategy(WaitStrategies.fixedWait(<span class="number">3</span>, TimeUnit.SECONDS))</span><br><span class="line">        .withStopStrategy(StopStrategies.stopAfterAttempt(<span class="number">3</span>))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        retryer.call(() -&gt; helloService.hello());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先创建一个<em>Retryer</em>实例，然后使用这个实例对需要重试的方法进行调用，可以通过很多方法来设置重试机制，比如使用<em>retryIfException</em>来对所有异常进行重试，使用<em>retryIfExceptionOfType</em>方法来设置对指定异常进行重试，使用<em>retryIfResult</em>来对不符合预期的返回结果进行重试，使用<em>retryIfRuntimeException</em>方法来对所有<em>RuntimeException</em>进行重试。</p>
<p>还有五个以<em>with</em>开头的方法，用来对重试策略/等待策略/阻塞策略/单次任务执行时间限制/自定义监听器进行设置，以实现更加强大的异常处理。</p>
<p>通过跟 <code>Spring AOP</code> 的结合，可以实现比 <code>Spring Retry</code> 更加强大的重试功能。</p>
<p>仔细对比之下，<code>Guava Retry</code> 可以提供的特性有：</p>
<ol>
<li>可以设置任务单次执行的时间限制，如果超时则抛出异常。</li>
<li>可以设置重试监听器，用来执行额外的处理工作。</li>
<li>可以设置任务阻塞策略，即可以设置当前重试完成，下次重试开始前的这段时间做什么事情。</li>
<li>可以通过停止重试策略和等待策略结合使用来设置更加灵活的策略，比如指数等待时长并最多10次调用，随机等待时长并永不停止等等。</li>
</ol>
<p><img src="https://i.loli.net/2019/08/11/MFpbWwysvP6Zqo7.jpg" alt="GBvgTpbkyvbhlEB.jpg"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文由浅入深的对多种重试的姿势进行了360度无死角教学，从最简单的手动重试，到使用静态代理，再到 <code>JDK动态代理</code> 和 <code>CGLib动态代理</code> ，再到 <code>Spring AOP</code>，都是手工造轮子的过程，最后介绍了两种目前比较好用的轮子，一个是<code>Spring Retry</code>，使用起来简单粗暴，与 <code>Spring</code> 框架天生搭配，一个注解搞定所有事情，另一个便是 <code>Guava Retry</code>，不依赖于 <code>Spring</code> 框架，自成体系，使用起来更加灵活强大。</p>
<p>个人认为，大部分场景下，<code>Spring Retry</code> 提供的重试机制已经足够强大，如果不需要 <code>Guava Retry</code> 提供的额外灵活性，使用 <code>Spring Retry</code> 就很棒了。当然，具体情况具体分析，但没有必要的情况下，不鼓励重复造轮子，先把别人的轮子研究清楚再想想还用不用自己动手。</p>
<p>本文到此就告一段落了，又用了一天的时间完成了完成了一篇文章，写作的目的在于总结和分享，我相信最佳实践是可以总结和积累下来的，在大多数场景下都是适用的，这些最佳实践会在逐渐的积累过程中，成为比经验更为重要的东西。因为经验不总结就会忘记，而总结出来的内容却不会被丢失。</p>
<p>如果对于重试你有更好的想法，欢迎提出交流探讨，也欢迎关注我的公众号进行留言交流。</p>
<p><img src="https://i.loli.net/2019/08/11/8MxBPNgyIlTZDRk.png" alt="1565529015677.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://good19961106.github.io/2020/05/04/best-practice/how-to-retry-elegantly/" data-id="ckjjnjndo003pa8wc4c8e08iz" data-title="【最佳实践】如何优雅的进行重试" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breeze-blog/tags/Spring/" rel="tag">Spring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breeze-blog/tags/%E4%BC%98%E9%9B%85%E9%87%8D%E8%AF%95/" rel="tag">优雅重试</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/breeze-blog/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" rel="tag">最佳实践</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/breeze-blog/2020/05/04/rabbitmq/rabbitmq-how-to-ensure-reliable-delivery-of-message/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          【RabbitMQ】如何进行消息可靠投递【上篇】
        
      </div>
    </a>
  
  
    <a href="/breeze-blog/2020/05/04/java/basic/java-class/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">【Java基础篇】四、Java 类与对象</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/breeze-blog/categories/%E7%BC%96%E7%A8%8B/">编程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/breeze-blog/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a></li><li class="category-list-item"><a class="category-list-link" href="/breeze-blog/categories/%E7%BC%96%E7%A8%8B/%E7%94%9F%E6%B4%BB/">生活</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/DelayQueue/" rel="tag">DelayQueue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/Java%E5%85%A5%E9%97%A8/" rel="tag">Java入门</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag">Java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/R/" rel="tag">R</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/RabbitMQ/" rel="tag">RabbitMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/Thoughts/" rel="tag">Thoughts</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/github-pages/" rel="tag">github pages</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/go/" rel="tag">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/travis-ci/" rel="tag">travis ci</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/%E4%BC%98%E9%9B%85%E9%87%8D%E8%AF%95/" rel="tag">优雅重试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" rel="tag">最佳实践</a></li><li class="tag-list-item"><a class="tag-list-link" href="/breeze-blog/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">环境搭建</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/breeze-blog/tags/DelayQueue/" style="font-size: 10px;">DelayQueue</a> <a href="/breeze-blog/tags/Hexo/" style="font-size: 12.86px;">Hexo</a> <a href="/breeze-blog/tags/Java/" style="font-size: 20px;">Java</a> <a href="/breeze-blog/tags/Java%E5%85%A5%E9%97%A8/" style="font-size: 18.57px;">Java入门</a> <a href="/breeze-blog/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 15.71px;">Java基础</a> <a href="/breeze-blog/tags/R/" style="font-size: 11.43px;">R</a> <a href="/breeze-blog/tags/RabbitMQ/" style="font-size: 14.29px;">RabbitMQ</a> <a href="/breeze-blog/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/breeze-blog/tags/Thoughts/" style="font-size: 11.43px;">Thoughts</a> <a href="/breeze-blog/tags/github-pages/" style="font-size: 10px;">github pages</a> <a href="/breeze-blog/tags/go/" style="font-size: 12.86px;">go</a> <a href="/breeze-blog/tags/travis-ci/" style="font-size: 10px;">travis ci</a> <a href="/breeze-blog/tags/%E4%BC%98%E9%9B%85%E9%87%8D%E8%AF%95/" style="font-size: 10px;">优雅重试</a> <a href="/breeze-blog/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" style="font-size: 10px;">最佳实践</a> <a href="/breeze-blog/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" style="font-size: 17.14px;">环境搭建</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/breeze-blog/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/breeze-blog/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/breeze-blog/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/breeze-blog/archives/2020/05/">May 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/breeze-blog/2021/01/05/picture/go-draw-word-in-pic2/">(no title)</a>
          </li>
        
          <li>
            <a href="/breeze-blog/2021/01/05/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/breeze-blog/2020/12/20/picture/go-draw-word-in-pic/">【Go语言绘图】图片添加文字（一）</a>
          </li>
        
          <li>
            <a href="/breeze-blog/2020/12/16/picture/go-pic-rotate-use-gg-package/">【Go语言绘图】图片的旋转</a>
          </li>
        
          <li>
            <a href="/breeze-blog/2020/11/29/picture/go-basic-usage-of-gg-package/">【Go语言绘图】gg 库的基本使用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/breeze-blog/" class="mobile-nav-link">Home</a>
  
    <a href="/breeze-blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/breeze-blog/js/jquery-3.4.1.min.js"></script>



  
<script src="/breeze-blog/fancybox/jquery.fancybox.min.js"></script>




<script src="/breeze-blog/js/script.js"></script>





  </div>
</body>
</html>